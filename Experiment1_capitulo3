{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "8b798ebf",
   "metadata": {
    "papermill": {
     "duration": 0.003853,
     "end_time": "2025-03-05T11:55:07.346954",
     "exception": false,
     "start_time": "2025-03-05T11:55:07.343101",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "77c0920d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:07.354854Z",
     "iopub.status.busy": "2025-03-05T11:55:07.354555Z",
     "iopub.status.idle": "2025-03-05T11:55:14.881643Z",
     "shell.execute_reply": "2025-03-05T11:55:14.880645Z"
    },
    "papermill": {
     "duration": 7.533074,
     "end_time": "2025-03-05T11:55:14.883479",
     "exception": false,
     "start_time": "2025-03-05T11:55:07.350405",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import torch\n",
    "from PIL import Image\n",
    "from torchvision import transforms\n",
    "\n",
    "class HistogramEqualization:\n",
    "    \"\"\"Aplica ecualización de histograma para ajuste de contraste\"\"\"\n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar ecualización de histograma por canal\n",
    "        if len(img_np.shape) == 3:  # Imagen RGB\n",
    "            img_eq = np.zeros_like(img_np)\n",
    "            for i in range(3):\n",
    "                img_eq[:,:,i] = cv2.equalizeHist(img_np[:,:,i])\n",
    "        else:  # Imagen en escala de grises\n",
    "            img_eq = cv2.equalizeHist(img_np)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_eq)\n",
    "\n",
    "class BilateralFilter:\n",
    "    \"\"\"Aplica filtrado bilateral para suavizado preservando bordes\"\"\"\n",
    "    def __init__(self, d=9, sigma_color=75, sigma_space=75):\n",
    "        self.d = d  # Diámetro de cada vecindario de píxeles\n",
    "        self.sigma_color = sigma_color  # Filtro sigma en el espacio de color\n",
    "        self.sigma_space = sigma_space  # Filtro sigma en el espacio de coordenadas\n",
    "    \n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar filtro bilateral\n",
    "        img_filtered = cv2.bilateralFilter(\n",
    "            img_np, self.d, self.sigma_color, self.sigma_space)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_filtered)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "aac55a88",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:14.891432Z",
     "iopub.status.busy": "2025-03-05T11:55:14.891067Z",
     "iopub.status.idle": "2025-03-05T11:55:14.902186Z",
     "shell.execute_reply": "2025-03-05T11:55:14.901462Z"
    },
    "papermill": {
     "duration": 0.016409,
     "end_time": "2025-03-05T11:55:14.903468",
     "exception": false,
     "start_time": "2025-03-05T11:55:14.887059",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "class DatasetExperiment1(Dataset):\n",
    "    def __init__(self, mode='train', batch_size=32,grey = False, local = False, path = ''):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            mode (str): 'train', 'val' o 'test'.\n",
    "            transform: Transformaciones de torchvision a aplicar a las imágenes.\n",
    "        \"\"\"\n",
    "        assert mode in ['train', 'val', 'test'], \"Mode must be 'train', 'val', or 'test'\"\n",
    "        if local:\n",
    "            print(\"LOCAL MODE ENABLED\")\n",
    "        self.grey = grey\n",
    "        # Transformaciones del paper\n",
    "        # Histogram equalization for contrast adjustment\n",
    "        # and bilateral filtering for smoothness\n",
    "        self.transform =  transforms.Compose([\n",
    "            transforms.Resize((224, 224)),\n",
    "            HistogramEqualization(),\n",
    "            BilateralFilter(d=9, sigma_color=75, sigma_space=75),\n",
    "            transforms.ToTensor(),\n",
    "        ])\n",
    "        self.data_path = os.path.join(path, mode)\n",
    "        self.classes = sorted(os.listdir(self.data_path))  # Lista de clases\n",
    "        self.data = []\n",
    "        self.batch_size = batch_size\n",
    "        # Cargar imágenes con sus etiquetas\n",
    "        \n",
    "\n",
    "        for label, class_name in enumerate(self.classes):\n",
    "            class_path = os.path.join(self.data_path, class_name)\n",
    "            i = 0\n",
    "            for img_name in os.listdir(class_path):\n",
    "                if local and i >= 3:\n",
    "                    break\n",
    "                img_path = os.path.join(class_path, img_name)\n",
    "                self.data.append((img_path, label))\n",
    "                i += 1\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        img_path, label = self.data[idx]\n",
    "        if not self.grey:\n",
    "            image = Image.open(img_path).convert('RGB')\n",
    "        else:\n",
    "            image = Image.open(img_path).convert('L')\n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "        \n",
    "        return image, label\n",
    "    \n",
    "    def get_dataloader(self, shuffle=True):       \n",
    "        return DataLoader(self, batch_size=self.batch_size, shuffle=shuffle)\n",
    "    def show_image(self, idx, transformed=True, figsize=(10, 8)):\n",
    "        \"\"\"\n",
    "        Muestra una imagen del dataset con su etiqueta\n",
    "        \n",
    "        Args:\n",
    "            idx (int): Índice de la imagen a mostrar\n",
    "            transformed (bool): Si es True, muestra la imagen transformada. \n",
    "                               Si es False, muestra la imagen original.\n",
    "            figsize (tuple): Tamaño de la figura (ancho, alto)\n",
    "        \"\"\"\n",
    "        if idx >= len(self):\n",
    "            print(f\"Índice {idx} fuera de rango. El dataset tiene {len(self)} elementos.\")\n",
    "            return\n",
    "        \n",
    "        img_path, label = self.data[idx]\n",
    "        class_name = self.classes[label]\n",
    "        \n",
    "        plt.figure(figsize=figsize)\n",
    "        \n",
    "        # Mostrar imagen original\n",
    "        orig_img = Image.open(img_path).convert('RGB')\n",
    "        plt.subplot(1, 2, 1)\n",
    "        plt.imshow(orig_img)\n",
    "        plt.title(f\"Original: Clase {class_name} (label {label})\")\n",
    "        plt.axis('off')\n",
    "        \n",
    "        # Mostrar imagen transformada si se solicita\n",
    "        if transformed:\n",
    "            trans_img = self.transform(orig_img)\n",
    "            # Convertir tensor a numpy para visualización\n",
    "            if isinstance(trans_img, torch.Tensor):\n",
    "                trans_img = trans_img.permute(1, 2, 0).numpy()  # Cambiar de CxHxW a HxWxC\n",
    "                # Normalizar valores para visualización\n",
    "                trans_img = np.clip(trans_img, 0, 1)\n",
    "            \n",
    "            plt.subplot(1, 2, 2)\n",
    "            plt.imshow(trans_img)\n",
    "            plt.title(\"Con transformaciones aplicadas\")\n",
    "            plt.axis('off')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Imprimir información adicional\n",
    "        print(f\"Ruta de la imagen: {img_path}\")\n",
    "        print(f\"Clase: {class_name} (label {label})\")\n",
    "        print(f\"Resolución original: {orig_img.size}\")\n",
    "        if transformed and isinstance(trans_img, np.ndarray):\n",
    "            print(f\"Resolución después de transformaciones: {trans_img.shape[:2]}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "56e13f65",
   "metadata": {
    "papermill": {
     "duration": 0.002868,
     "end_time": "2025-03-05T11:55:14.909683",
     "exception": false,
     "start_time": "2025-03-05T11:55:14.906815",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train config 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee2493c3",
   "metadata": {
    "papermill": {
     "duration": 0.002898,
     "end_time": "2025-03-05T11:55:14.915601",
     "exception": false,
     "start_time": "2025-03-05T11:55:14.912703",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The hyperparameters of the proposed ensemble model were\n",
    "tuned by the trial-and-error method. \n",
    "L2 regularization, \n",
    "batch normalization, \n",
    "dropout rate\n",
    "\n",
    "The Adam optimizer\n",
    "Epochs = 150. \n",
    "The learning rate scheduler and ReduceLROnPlateau were used for handling\n",
    "the learning rate with an initial value of 0.001. The loss\n",
    "function used for the model was categorical cross-entropy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "842c5184",
   "metadata": {
    "papermill": {
     "duration": 0.002827,
     "end_time": "2025-03-05T11:55:14.921512",
     "exception": false,
     "start_time": "2025-03-05T11:55:14.918685",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Trainer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "28eed768",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:14.928722Z",
     "iopub.status.busy": "2025-03-05T11:55:14.928442Z",
     "iopub.status.idle": "2025-03-05T11:55:23.530753Z",
     "shell.execute_reply": "2025-03-05T11:55:23.529771Z"
    },
    "papermill": {
     "duration": 8.607958,
     "end_time": "2025-03-05T11:55:23.532456",
     "exception": false,
     "start_time": "2025-03-05T11:55:14.924498",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install -q lightning\n",
    "import lightning.pytorch as pl\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torchmetrics as tm\n",
    "from torchmetrics.classification import MulticlassConfusionMatrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "class Classification(pl.LightningModule):\n",
    "    \"\"\"\n",
    "    Trainer para entrenar un modelo de clasificación multiclase\n",
    "    y de dimension 1 con valores [0, num_classes]\n",
    "    \"\"\"\n",
    "    def __init__(self, model, device, L1=0.001, L2=0.001, lr=0.001, patience=5, factor=0.1, betas=(0.9, 0.999)):\n",
    "        super().__init__()\n",
    "        self.save_hyperparameters(ignore=(\"model\",))\n",
    "\n",
    "        self.model = model\n",
    "\n",
    "        self.loss_fn = nn.CrossEntropyLoss()\n",
    "        self.L1 = L1\n",
    "        self.L2 = L2\n",
    "        self.learning_rate = lr\n",
    "        self.patience = patience\n",
    "        self.factor = factor\n",
    "        self.betas = betas\n",
    "\n",
    "        self.num_classes = 5\n",
    "        self.confusion_matrix = MulticlassConfusionMatrix(num_classes=5).to(device)\n",
    "        self.auc_metric = tm.AUROC(num_classes=5, task=\"multiclass\").to(device)  # Definir métrica AUROC para clasificación multiclase\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.model(x)\n",
    "\n",
    "    def training_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        \n",
    "        # Regularización L1\n",
    "        L1_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L1_reg = L1_reg + torch.sum(torch.abs(param))\n",
    "        \n",
    "        # Regularización L2\n",
    "        L2_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L2_reg = L2_reg + torch.sum(param ** 2)\n",
    "        \n",
    "        # Añadir regularización a la pérdida\n",
    "        prediction_loss = loss\n",
    "        loss = loss + self.L1 * L1_reg + self.L2 * L2_reg\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        loss.backward()\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "\n",
    "        return {\"loss\": prediction_loss, \"real_loss\": loss, \"ACC\": ACC, \"recall\": recall, \"precision\": precision, \"f1_score\": f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def validation_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "        return {\"loss\": loss, \"ACC\": ACC, \"precision\" : precision, \"recall\": recall, \"f1_score\" : f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def transform_classes(self, y):\n",
    "        # Convertir las clases a un formato de one-hot encoding\n",
    "        return torch.nn.functional.one_hot(y.to(torch.int64), num_classes=5).to(float).squeeze()\n",
    "    def restart_epoch(self, plot = False):\n",
    "        if plot:\n",
    "            self.plot()\n",
    "        self.confusion_matrix.reset()\n",
    "        self.auc_metric.reset()\n",
    "    def calculate_metrics_from_confusion_matrix(self):\n",
    "        # Obtener la matriz de confusión (suponiendo que es un tensor de torch)\n",
    "        cm = self.confusion_matrix.compute()\n",
    "        total_samples = cm.sum()\n",
    "        \n",
    "        # Verdaderos positivos por clase (diagonal de la matriz)\n",
    "        true_positives = torch.diag(cm)\n",
    "        \n",
    "        # Predicciones totales por clase (sumar columnas)\n",
    "        predicted_positives = cm.sum(dim=0)\n",
    "        \n",
    "        # Ejemplos reales por clase (sumar filas)\n",
    "        actual_positives = cm.sum(dim=1)\n",
    "        \n",
    "        # Calcular falsos positivos y falsos negativos por clase\n",
    "        false_positives = predicted_positives - true_positives\n",
    "        false_negatives = actual_positives - true_positives\n",
    "        \n",
    "        # Calcular verdaderos negativos por clase\n",
    "        true_negatives = total_samples - (actual_positives + predicted_positives - true_positives)\n",
    "        \n",
    "        # Calcular métricas por clase con robustez para evitar división por cero\n",
    "        precision_per_class = true_positives / (predicted_positives + 1e-8)\n",
    "        recall_per_class = true_positives / (actual_positives + 1e-8)\n",
    "        specificity_per_class = true_negatives / (true_negatives + false_positives + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Promediar las métricas por clase\n",
    "        precision = precision_per_class.mean()\n",
    "        recall = recall_per_class.mean()\n",
    "        specificity = specificity_per_class.mean()\n",
    "        f1 = f1_per_class.mean()\n",
    "        \n",
    "        # Calcular Accuracy (exactitud)\n",
    "        ACC = true_positives.sum() / total_samples\n",
    "        \n",
    "        # Calcular el AUC (suponiendo que self.auc_metric ya está correctamente definido)\n",
    "        AUC = self.auc_metric.compute()\n",
    "        \n",
    "        return precision, recall, f1, ACC, AUC, specificity\n",
    "\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        optimizer = torch.optim.Adam(self.model.parameters(),\n",
    "                                     lr=self.learning_rate,\n",
    "                                     betas=self.betas)\n",
    "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer,\n",
    "                                                               factor=self.factor,\n",
    "                                                               patience=self.patience)\n",
    "        return optimizer, scheduler\n",
    "    def plot(self, epoch=0):\n",
    "        # Computa la matriz de confusión y las métricas por clase\n",
    "        cm = self.confusion_matrix.compute().cpu().numpy()\n",
    "        support = cm.sum(axis=1)\n",
    "        precision_per_class = np.diag(cm) / (cm.sum(axis=0) + 1e-8)\n",
    "        recall_per_class = np.diag(cm) / (cm.sum(axis=1) + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Cálculo de especificidad por clase\n",
    "        FP = cm.sum(axis=0) - np.diag(cm)\n",
    "        FN = cm.sum(axis=1) - np.diag(cm)\n",
    "        TN = cm.sum() - (FP + FN + np.diag(cm))\n",
    "        specificity_per_class = TN / (TN + FP + 1e-8)\n",
    "        \n",
    "        accuracy = np.diag(cm).sum() / cm.sum()\n",
    "\n",
    "        # Crea dos subplots: uno para la matriz de confusión y otro para la tabla de métricas\n",
    "        fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "        # Subplot 1: Matriz de confusión con heatmap\n",
    "        sns.heatmap(cm, annot=True, fmt=\"d\", ax=axs[0], cmap=\"Blues\")\n",
    "        axs[0].set_title(\"Matriz de Confusión epoch \" + str(epoch))\n",
    "        axs[0].set_xlabel(\"Predicción\")\n",
    "        axs[0].set_ylabel(\"Real\")\n",
    "\n",
    "        # Subplot 2: Tabla de métricas por clase\n",
    "        table_data = []\n",
    "        for i in range(self.num_classes):\n",
    "            table_data.append([f\"Clase {i}\",\n",
    "                            f\"{precision_per_class[i]:.2f}\",\n",
    "                            f\"{recall_per_class[i]:.2f}\",\n",
    "                            f\"{f1_per_class[i]:.2f}\",\n",
    "                            f\"{specificity_per_class[i]:.2f}\",\n",
    "                            int(support[i])])\n",
    "        axs[1].axis('tight')\n",
    "        axs[1].axis('off')\n",
    "        table = axs[1].table(cellText=table_data,\n",
    "                            colLabels=[\"Clase\", \"Precision\", \"Sensivity/Recall\", \"F1\", \"Specificity\", \"Support\"],\n",
    "                            cellLoc=\"center\", loc=\"center\")\n",
    "        axs[1].set_title(f\"Metrics por clase\\nAccuracy General: {accuracy:.2f}\", pad=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "99884aa1",
   "metadata": {
    "papermill": {
     "duration": 0.002927,
     "end_time": "2025-03-05T11:55:23.539018",
     "exception": false,
     "start_time": "2025-03-05T11:55:23.536091",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "291e56f8",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:23.546134Z",
     "iopub.status.busy": "2025-03-05T11:55:23.545764Z",
     "iopub.status.idle": "2025-03-05T11:55:23.553030Z",
     "shell.execute_reply": "2025-03-05T11:55:23.552326Z"
    },
    "papermill": {
     "duration": 0.012201,
     "end_time": "2025-03-05T11:55:23.554178",
     "exception": false,
     "start_time": "2025-03-05T11:55:23.541977",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.nn import functional as F\n",
    "import torchvision.models as models\n",
    "\n",
    "class ResNet50Model(nn.Module):\n",
    "    \"\"\"\n",
    "    Modelo basado en ResNet50 para la clasificación de radiografías.\n",
    "    Permite personalización en el número de clases y si se usa transfer learning.\n",
    "    \"\"\"\n",
    "    def __init__(self, num_classes=5, pretrained=True, grey = False, dropout_rate=0.3):\n",
    "        \"\"\"\n",
    "        Inicializa el modelo ResNet50.\n",
    "        \n",
    "        Args:\n",
    "            num_classes (int): Número de clases para la clasificación (default: 5)\n",
    "            pretrained (bool): Si se deben usar pesos preentrenados en ImageNet (default: True)\n",
    "            freeze_backbone (bool): Si se deben congelar las capas de la red base (default: False)\n",
    "            dropout_rate (float): Tasa de dropout aplicada antes de la capa de clasificación (default: 0.3)\n",
    "        \"\"\"\n",
    "        super(ResNet50Model, self).__init__()\n",
    "        \n",
    "        # Cargar el modelo base ResNet50\n",
    "        self.model = models.resnet50(weights='IMAGENET1K_V2' if pretrained else None)\n",
    "        \n",
    "        # Nombre del modelo para identificación\n",
    "        self.name = \"ResNet50\"\n",
    "        \n",
    "        \n",
    "        # Reemplazar la capa de clasificación final\n",
    "        in_features = self.model.fc.in_features\n",
    "        self.model.fc = nn.Sequential(\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(in_features, 512),\n",
    "            nn.ReLU(),\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(512, num_classes)\n",
    "        )\n",
    "        if grey:\n",
    "            # Guardamos la capa original\n",
    "            original_conv = self.model.conv1\n",
    "            # Creamos una nueva capa que acepte 1 canal de entrada\n",
    "            self.model.conv1 = nn.Conv2d(\n",
    "                in_channels=1, \n",
    "                out_channels=original_conv.out_channels, \n",
    "                kernel_size=original_conv.kernel_size, \n",
    "                stride=original_conv.stride, \n",
    "                padding=original_conv.padding, \n",
    "                bias=False\n",
    "            )\n",
    "            if pretrained:\n",
    "                # Inicializamos los pesos promediando los de los 3 canales originales\n",
    "                self.model.conv1.weight.data = original_conv.weight.data.mean(dim=1, keepdim=True)\n",
    "        \n",
    "    \n",
    "    def forward(self, x):\n",
    "        \"\"\"\n",
    "        Propagación hacia adelante a través del modelo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor con las predicciones de clase [batch_size, num_classes]\n",
    "        \"\"\"\n",
    "        return self.model(x)\n",
    "    \n",
    "    def get_features(self, x):\n",
    "        \"\"\"\n",
    "        Obtiene los features del modelo antes de la capa de clasificación.\n",
    "        Útil para análisis de características o transferencia de estilo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor de características [batch_size, 2048]\n",
    "        \"\"\"\n",
    "        # Extrae todas las capas excepto la final\n",
    "        modules = list(self.model.children())[:-1]\n",
    "        feature_extractor = nn.Sequential(*modules)\n",
    "        \n",
    "        # Obtiene los features y los aplana\n",
    "        features = feature_extractor(x)\n",
    "        features = features.view(features.size(0), -1)\n",
    "        \n",
    "        return features\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3b2ac0e1",
   "metadata": {
    "papermill": {
     "duration": 0.002926,
     "end_time": "2025-03-05T11:55:23.560447",
     "exception": false,
     "start_time": "2025-03-05T11:55:23.557521",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "9433fb3c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:23.567663Z",
     "iopub.status.busy": "2025-03-05T11:55:23.567439Z",
     "iopub.status.idle": "2025-03-05T11:55:25.378670Z",
     "shell.execute_reply": "2025-03-05T11:55:25.377750Z"
    },
    "papermill": {
     "duration": 1.816515,
     "end_time": "2025-03-05T11:55:25.380299",
     "exception": false,
     "start_time": "2025-03-05T11:55:23.563784",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "from tqdm import tqdm\n",
    "from wandb import wandb\n",
    "\n",
    "def create_tqdm_bar(iterable, desc, mode):\n",
    "    return tqdm(enumerate(iterable),total=len(iterable), ncols=200, desc=desc)\n",
    "\n",
    "def train_model(model, trainer, train_dataset, val_dataset, epochs=5, transform=None, device='cuda', save_model = \"\", name=\"Test\", wdb=True, local=False, project=\"oai-knee-cartilage-segmentation\"):\n",
    "    if wdb:\n",
    "        if wandb.run is not None:\n",
    "            wandb.finish()\n",
    "        wandb.init(\n",
    "            project=project,\n",
    "            name=name,\n",
    "            # track hyperparameters and run metadata\n",
    "            config={\n",
    "                \"model\": model.name,\n",
    "                \"Batch_size\": train_dataset.batch_size,\n",
    "                \"learning_rate\": trainer.learning_rate,\n",
    "                \"L1\": trainer.L1,\n",
    "                \"L2\": trainer.L2,\n",
    "                \"patience\": trainer.patience,\n",
    "                \"factor\": trainer.factor,\n",
    "                \"betas\": trainer.betas,\n",
    "                \"epochs\": epochs,\n",
    "            }\n",
    "        )\n",
    "    train_loader = train_dataset.get_dataloader(shuffle=True)\n",
    "    val_loader = val_dataset.get_dataloader(shuffle=True)\n",
    "    model.to(device)\n",
    "    train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = local, save_model = save_model)\n",
    "    \n",
    "\n",
    "def train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = False, save_model = \"\"):\n",
    "    \"\"\"\n",
    "    train the given model\n",
    "    \"\"\"\n",
    "    optimizer, scheduler = trainer.configure_optimizers()\n",
    "    best_model = None\n",
    "    best_loss = float('inf')\n",
    "    for epoch in range(epochs):        \n",
    "        training_loss = []\n",
    "        validation_loss = []\n",
    "\n",
    "        training_loss_num = 0\n",
    "        complete_loss_num = 0\n",
    "        validation_loss_num = 0\n",
    "\n",
    "        # use training data\n",
    "        model.train()\n",
    "\n",
    "        training_loop = create_tqdm_bar(train_loader, desc=f'Training Epoch [{epoch + 1}/{epochs}]', mode='train')\n",
    "        for train_iteration, batch in training_loop:\n",
    "            batch = batch[0].to(device), batch[1].to(device)\n",
    "            optimizer.zero_grad()\n",
    "            res = trainer.training_step(batch[0], batch[1])\n",
    "            optimizer.step()\n",
    "\n",
    "            training_loss.append(res['loss'].item())\n",
    "            training_loss_num += res['loss'].item()\n",
    "            complete_loss_num += res['real_loss'].item()\n",
    "            # Update the progress bar.\n",
    "            training_loop.set_postfix(train_loss=\"{:.4f}\".format(training_loss_num / (train_iteration + 1)),\n",
    "                                      complete_loss=\"{:.4f}\".format(complete_loss_num / (train_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      sensivity=res['recall'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "            if wdb:\n",
    "                \n",
    "                wandb.log({\"train_loss\": training_loss_num / (train_iteration + 1),\n",
    "                           \"complete_loss\": complete_loss_num / (train_iteration + 1),\n",
    "                        \"train_acc\": res['ACC'],\n",
    "                        \"train_recall\": res['recall'].item(),\n",
    "                        \"train_precision\": res['precision'].item(),\n",
    "                        \"train_specifity\": res['specificity'].item(),\n",
    "                        \"train_f1_score\": res['f1_score'].item(),\n",
    "                        \"train_AUC\": res['AUC'],\n",
    "                        \"epoch\": epoch,\n",
    "                        \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        trainer.restart_epoch(plot=False)\n",
    "        # use validation data\n",
    "        if local:\n",
    "            continue\n",
    "        model.eval()\n",
    "        val_loop = create_tqdm_bar(val_loader, desc=f'Validation Epoch [{epoch + 1}/{epochs}]', mode='val')\n",
    "        with torch.no_grad():\n",
    "            for val_iteration, batch in val_loop:\n",
    "                batch = batch[0].to(device), batch[1].to(device)\n",
    "                res = trainer.validation_step(batch[0], batch[1])  \n",
    "                validation_loss.append(res['loss'].item())\n",
    "                validation_loss_num += res['loss'].item()\n",
    "                val_loop.set_postfix(val_loss = \"{:.8f}\".format(validation_loss_num / (val_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "                                      \n",
    "        if wdb:\n",
    "            wandb.log({\"val_loss\": validation_loss_num / (val_iteration + 1),\n",
    "                    \"val_acc\": res['ACC'],\n",
    "                    \"val_recall\": res['recall'].item(),\n",
    "                    \"val_precision\": res['precision'].item(),\n",
    "                    \"val_specificity\": res['specificity'].item(),\n",
    "                    \"val_f1_score\": res['f1_score'].item(),\n",
    "                    \"val_AUC\": res['AUC'],\n",
    "                    \"epoch\": epoch,\n",
    "                    \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        if validation_loss_num < best_loss:\n",
    "            best_loss = validation_loss_num\n",
    "            if save_model != \"\":\n",
    "                torch.save(model.state_dict(), f\"best_model_{model.__class__.__name__}_{save_model}_epoch_{epoch}.pt\")\n",
    "        scheduler.step(validation_loss_num)\n",
    "        trainer.restart_epoch(plot=False)\n",
    "    \n",
    "    test_model(model, val_loader, trainer, device, wdb)\n",
    "\n",
    "def test_model(model, test_loader, trainer, device, wdb=False):\n",
    "    \"\"\"\n",
    "    Test the given model\n",
    "    \"\"\"\n",
    "    model.eval()\n",
    "    model.to(device)\n",
    "\n",
    "    epoch_loss = 0.0\n",
    "    avg_loss = 0.0\n",
    "    trainer.restart_epoch(plot = False)\n",
    "    for batch in test_loader:\n",
    "        inputs, labels = batch\n",
    "        inputs = inputs.to(device)\n",
    "        \n",
    "        labels = labels.to(device)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            res = trainer.validation_step(inputs, labels)\n",
    "            # Extraer valores escalares\n",
    "            loss = res['loss']\n",
    "            \n",
    "        loss_value = loss.item()\n",
    "        # Calcular promedios\n",
    "        epoch_loss += loss_value\n",
    "\n",
    "    ACC_value = res['ACC']\n",
    "    recall_value = res['recall'].item()\n",
    "    precision_value = res['precision'].item()\n",
    "    f1_score_value = res['f1_score'].item()\n",
    "    AUC_value = res['AUC']\n",
    "    avg_loss = epoch_loss / len(test_loader)\n",
    "    if wdb:\n",
    "        wandb.log({\"test_loss\": avg_loss, \"test_acc\": ACC_value.item(),\n",
    "                \"test_recall\": recall_value, \"test_precision\": precision_value,\n",
    "                \"test_f1_score\": f1_score_value, \"test_AUC\" : AUC_value})\n",
    "    \n",
    "    print(f\"Test model {model.__class__.__name__} - Loss: {avg_loss:.2f}, ACC: {ACC_value:.2f}, AUC: {AUC_value:.2f}, Sensivility: {recall_value:.2f}, Specificity: {precision_value:.2f}\")\n",
    "\n",
    "    trainer.restart_epoch(plot = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "30640a6c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:25.387866Z",
     "iopub.status.busy": "2025-03-05T11:55:25.387594Z",
     "iopub.status.idle": "2025-03-05T11:55:26.453505Z",
     "shell.execute_reply": "2025-03-05T11:55:26.452841Z"
    },
    "papermill": {
     "duration": 1.071402,
     "end_time": "2025-03-05T11:55:26.455145",
     "exception": false,
     "start_time": "2025-03-05T11:55:25.383743",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import os\n",
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "BATCH_SIZE = 64\n",
    "LEARNING_RATE = 0.001\n",
    "FACTOR = 0.1\n",
    "L1 = 0.00\n",
    "L2 = 0.0001\n",
    "PATIENCE = 5\n",
    "BETAS=(0.9, 0.999)\n",
    "GREY = True\n",
    "DATASET_PATH = '/kaggle/input/aug-oai-capitulo3/augmented_oai'\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "train_dataset = DatasetExperiment1('train', batch_size=BATCH_SIZE, local=False,grey=True, path = DATASET_PATH)\n",
    "val_dataset = DatasetExperiment1('val', batch_size=BATCH_SIZE, local=False, grey=True, path = DATASET_PATH)\n",
    "model = ResNet50Model(num_classes=len(train_dataset.classes), dropout_rate=0.5,grey = True, pretrained = False)\n",
    "trainer = Classification(model, device, L1=L1, L2=L2, lr=LEARNING_RATE, patience=PATIENCE, factor=FACTOR, betas=BETAS)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "840d09e5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:26.462570Z",
     "iopub.status.busy": "2025-03-05T11:55:26.462301Z",
     "iopub.status.idle": "2025-03-05T11:55:27.633321Z",
     "shell.execute_reply": "2025-03-05T11:55:27.632448Z"
    },
    "papermill": {
     "duration": 1.176338,
     "end_time": "2025-03-05T11:55:27.634886",
     "exception": false,
     "start_time": "2025-03-05T11:55:26.458548",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Using wandb-core as the SDK backend.  Please refer to https://wandb.me/wandb-core for more information.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33mchermar\u001b[0m (\u001b[33mchermar-universitat-polit-cnica-de-val-ncia\u001b[0m). Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m If you're specifying your api key in code, ensure this code is not shared publicly.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m Consider setting the WANDB_API_KEY environment variable, or running `wandb login` from the command line.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Appending key for api.wandb.ai to your netrc file: /root/.netrc\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wandb.login(key=\"254f72e7bdeec44797ba1b2a91ebbc63900b89f4\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "b8f42497",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T11:55:27.642862Z",
     "iopub.status.busy": "2025-03-05T11:55:27.642568Z",
     "iopub.status.idle": "2025-03-05T15:05:13.367523Z",
     "shell.execute_reply": "2025-03-05T15:05:13.366719Z"
    },
    "papermill": {
     "duration": 11385.730467,
     "end_time": "2025-03-05T15:05:13.369040",
     "exception": false,
     "start_time": "2025-03-05T11:55:27.638573",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Tracking run with wandb version 0.19.1\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run data is saved locally in \u001b[35m\u001b[1m/kaggle/working/wandb/run-20250305_115527-8676uy27\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run \u001b[1m`wandb offline`\u001b[0m to turn off syncing.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Syncing run \u001b[33m!pretrain\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: ⭐️ View project at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: 🚀 View run at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation/runs/8676uy27\u001b[0m\n",
      "Training Epoch [1/30]: 100%|███████████████████████████████████████| 459/459 [07:53<00:00,  1.03s/it, AUC=0.632, acc=0.417, complete_loss=5.5309, sensivity=0.249, specificity=0.817, train_loss=1.3559]\n",
      "Validation Epoch [1/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:08<00:00,  1.46it/s, AUC=0.634, acc=0.144, specificity=0.802, val_loss=2.32021862]\n",
      "Training Epoch [2/30]: 100%|███████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.722, acc=0.473, complete_loss=2.7537, sensivity=0.324, specificity=0.839, train_loss=1.2219]\n",
      "Validation Epoch [2/30]: 100%|██████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.95it/s, AUC=0.7, acc=0.315, specificity=0.825, val_loss=1.63566385]\n",
      "Training Epoch [3/30]: 100%|███████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.738, acc=0.485, complete_loss=1.9444, sensivity=0.339, specificity=0.845, train_loss=1.1911]\n",
      "Validation Epoch [3/30]: 100%|█████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.95it/s, AUC=0.733, acc=0.45, specificity=0.828, val_loss=1.28403422]\n",
      "Training Epoch [4/30]: 100%|███████████████████████████████████████| 459/459 [06:07<00:00,  1.25it/s, AUC=0.755, acc=0.498, complete_loss=1.6096, sensivity=0.353, specificity=0.849, train_loss=1.1580]\n",
      "Validation Epoch [4/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.96it/s, AUC=0.735, acc=0.433, specificity=0.817, val_loss=1.38242255]\n",
      "Training Epoch [5/30]: 100%|████████████████████████████████████████| 459/459 [06:09<00:00,  1.24it/s, AUC=0.765, acc=0.51, complete_loss=1.4557, sensivity=0.365, specificity=0.852, train_loss=1.1354]\n",
      "Validation Epoch [5/30]:   0%|                                                                                                                                                   | 0/13 [00:00<?, ?it/s]/usr/local/lib/python3.10/dist-packages/torchmetrics/utilities/prints.py:43: UserWarning: No positive samples in targets, true positive value should be meaningless. Returning zero tensor in true positive score\n",
      "  warnings.warn(*args, **kwargs)  # noqa: B028\n",
      "Validation Epoch [5/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.94it/s, AUC=0.733, acc=0.435, specificity=0.838, val_loss=1.20854266]\n",
      "Training Epoch [6/30]: 100%|███████████████████████████████████████| 459/459 [06:04<00:00,  1.26it/s, AUC=0.776, acc=0.521, complete_loss=1.3713, sensivity=0.377, specificity=0.857, train_loss=1.1150]\n",
      "Validation Epoch [6/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.92it/s, AUC=0.789, acc=0.515, specificity=0.858, val_loss=1.11087523]\n",
      "Training Epoch [7/30]: 100%|███████████████████████████████████████| 459/459 [06:08<00:00,  1.25it/s, AUC=0.785, acc=0.528, complete_loss=1.3057, sensivity=0.385, specificity=0.859, train_loss=1.0886]\n",
      "Validation Epoch [7/30]: 100%|██████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.97it/s, AUC=0.782, acc=0.5, specificity=0.843, val_loss=1.20301492]\n",
      "Training Epoch [8/30]: 100%|███████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.796, acc=0.543, complete_loss=1.2580, sensivity=0.398, specificity=0.864, train_loss=1.0653]\n",
      "Validation Epoch [8/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.97it/s, AUC=0.755, acc=0.326, specificity=0.826, val_loss=1.48876939]\n",
      "Training Epoch [9/30]: 100%|████████████████████████████████████████| 459/459 [06:10<00:00,  1.24it/s, AUC=0.801, acc=0.551, complete_loss=1.2280, sensivity=0.41, specificity=0.866, train_loss=1.0522]\n",
      "Validation Epoch [9/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.90it/s, AUC=0.773, acc=0.401, specificity=0.841, val_loss=1.30103651]\n",
      "Training Epoch [10/30]: 100%|███████████████████████████████████████| 459/459 [06:11<00:00,  1.24it/s, AUC=0.812, acc=0.563, complete_loss=1.1891, sensivity=0.433, specificity=0.87, train_loss=1.0245]\n",
      "Validation Epoch [10/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.91it/s, AUC=0.797, acc=0.476, specificity=0.857, val_loss=1.17416854]\n",
      "Training Epoch [11/30]: 100%|███████████████████████████████████████| 459/459 [06:10<00:00,  1.24it/s, AUC=0.814, acc=0.564, complete_loss=1.1722, sensivity=0.442, specificity=0.87, train_loss=1.0175]\n",
      "Validation Epoch [11/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.90it/s, AUC=0.809, acc=0.544, specificity=0.856, val_loss=1.09114412]\n",
      "Training Epoch [12/30]: 100%|███████████████████████████████████████| 459/459 [06:15<00:00,  1.22it/s, AUC=0.819, acc=0.568, complete_loss=1.1525, sensivity=0.45, specificity=0.871, train_loss=1.0050]\n",
      "Validation Epoch [12/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:07<00:00,  1.81it/s, AUC=0.743, acc=0.286, specificity=0.819, val_loss=1.57619572]\n",
      "Training Epoch [13/30]: 100%|██████████████████████████████████████| 459/459 [06:14<00:00,  1.23it/s, AUC=0.825, acc=0.579, complete_loss=1.1284, sensivity=0.478, specificity=0.874, train_loss=0.9863]\n",
      "Validation Epoch [13/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.87it/s, AUC=0.828, acc=0.554, specificity=0.873, val_loss=1.00429902]\n",
      "Training Epoch [14/30]: 100%|██████████████████████████████████████| 459/459 [06:11<00:00,  1.24it/s, AUC=0.829, acc=0.585, complete_loss=1.1140, sensivity=0.489, specificity=0.876, train_loss=0.9760]\n",
      "Validation Epoch [14/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.94it/s, AUC=0.781, acc=0.358, specificity=0.83, val_loss=1.44119219]\n",
      "Training Epoch [15/30]: 100%|████████████████████████████████████████| 459/459 [06:07<00:00,  1.25it/s, AUC=0.832, acc=0.589, complete_loss=1.1004, sensivity=0.5, specificity=0.877, train_loss=0.9658]\n",
      "Validation Epoch [15/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.91it/s, AUC=0.822, acc=0.549, specificity=0.873, val_loss=1.01316713]\n",
      "Training Epoch [16/30]: 100%|██████████████████████████████████████| 459/459 [06:08<00:00,  1.24it/s, AUC=0.836, acc=0.592, complete_loss=1.0887, sensivity=0.502, specificity=0.878, train_loss=0.9568]\n",
      "Validation Epoch [16/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.92it/s, AUC=0.824, acc=0.556, specificity=0.873, val_loss=1.00966400]\n",
      "Training Epoch [17/30]: 100%|███████████████████████████████████████| 459/459 [06:08<00:00,  1.25it/s, AUC=0.841, acc=0.598, complete_loss=1.0705, sensivity=0.514, specificity=0.88, train_loss=0.9401]\n",
      "Validation Epoch [17/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.97it/s, AUC=0.838, acc=0.588, specificity=0.878, val_loss=0.95580780]\n",
      "Training Epoch [18/30]: 100%|██████████████████████████████████████| 459/459 [06:09<00:00,  1.24it/s, AUC=0.845, acc=0.606, complete_loss=1.0599, sensivity=0.524, specificity=0.883, train_loss=0.9307]\n",
      "Validation Epoch [18/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.89it/s, AUC=0.84, acc=0.604, specificity=0.879, val_loss=0.94559241]\n",
      "Training Epoch [19/30]: 100%|██████████████████████████████████████| 459/459 [06:11<00:00,  1.24it/s, AUC=0.847, acc=0.612, complete_loss=1.0513, sensivity=0.532, specificity=0.884, train_loss=0.9223]\n",
      "Validation Epoch [19/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.93it/s, AUC=0.843, acc=0.601, specificity=0.881, val_loss=0.92492548]\n",
      "Training Epoch [20/30]: 100%|██████████████████████████████████████| 459/459 [06:07<00:00,  1.25it/s, AUC=0.854, acc=0.618, complete_loss=1.0279, sensivity=0.543, specificity=0.886, train_loss=0.8990]\n",
      "Validation Epoch [20/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.93it/s, AUC=0.797, acc=0.523, specificity=0.849, val_loss=1.18488386]\n",
      "Training Epoch [21/30]: 100%|███████████████████████████████████████| 459/459 [06:09<00:00,  1.24it/s, AUC=0.856, acc=0.62, complete_loss=1.0265, sensivity=0.544, specificity=0.887, train_loss=0.8975]\n",
      "Validation Epoch [21/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.91it/s, AUC=0.788, acc=0.446, specificity=0.852, val_loss=1.27542642]\n",
      "Training Epoch [22/30]: 100%|███████████████████████████████████████| 459/459 [06:08<00:00,  1.25it/s, AUC=0.86, acc=0.624, complete_loss=1.0121, sensivity=0.553, specificity=0.888, train_loss=0.8824]\n",
      "Validation Epoch [22/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.95it/s, AUC=0.815, acc=0.556, specificity=0.86, val_loss=1.10512501]\n",
      "Training Epoch [23/30]: 100%|███████████████████████████████████████| 459/459 [06:08<00:00,  1.24it/s, AUC=0.862, acc=0.631, complete_loss=1.0015, sensivity=0.573, specificity=0.89, train_loss=0.8706]\n",
      "Validation Epoch [23/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.92it/s, AUC=0.847, acc=0.603, specificity=0.879, val_loss=0.93247205]\n",
      "Training Epoch [24/30]: 100%|██████████████████████████████████████| 459/459 [06:10<00:00,  1.24it/s, AUC=0.868, acc=0.638, complete_loss=0.9850, sensivity=0.578, specificity=0.892, train_loss=0.8529]\n",
      "Validation Epoch [24/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.96it/s, AUC=0.852, acc=0.609, specificity=0.882, val_loss=1.02243248]\n",
      "Training Epoch [25/30]: 100%|██████████████████████████████████████| 459/459 [06:09<00:00,  1.24it/s, AUC=0.872, acc=0.642, complete_loss=0.9750, sensivity=0.582, specificity=0.893, train_loss=0.8418]\n",
      "Validation Epoch [25/30]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.97it/s, AUC=0.85, acc=0.587, specificity=0.878, val_loss=0.96992308]\n",
      "Training Epoch [26/30]: 100%|██████████████████████████████████████| 459/459 [06:07<00:00,  1.25it/s, AUC=0.899, acc=0.682, complete_loss=0.8740, sensivity=0.632, specificity=0.905, train_loss=0.7411]\n",
      "Validation Epoch [26/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.89it/s, AUC=0.862, acc=0.626, specificity=0.888, val_loss=0.93413352]\n",
      "Training Epoch [27/30]: 100%|██████████████████████████████████████| 459/459 [06:07<00:00,  1.25it/s, AUC=0.911, acc=0.704, complete_loss=0.8205, sensivity=0.659, specificity=0.913, train_loss=0.6885]\n",
      "Validation Epoch [27/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.92it/s, AUC=0.859, acc=0.627, specificity=0.891, val_loss=0.92886437]\n",
      "Training Epoch [28/30]: 100%|██████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.918, acc=0.721, complete_loss=0.7876, sensivity=0.685, specificity=0.918, train_loss=0.6563]\n",
      "Validation Epoch [28/30]: 100%|█████████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.96it/s, AUC=0.86, acc=0.617, specificity=0.89, val_loss=0.92849929]\n",
      "Training Epoch [29/30]: 100%|██████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.924, acc=0.735, complete_loss=0.7575, sensivity=0.712, specificity=0.923, train_loss=0.6266]\n",
      "Validation Epoch [29/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.98it/s, AUC=0.857, acc=0.618, specificity=0.886, val_loss=0.99712834]\n",
      "Training Epoch [30/30]: 100%|██████████████████████████████████████| 459/459 [06:06<00:00,  1.25it/s, AUC=0.928, acc=0.742, complete_loss=0.7372, sensivity=0.722, specificity=0.925, train_loss=0.6067]\n",
      "Validation Epoch [30/30]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:06<00:00,  1.92it/s, AUC=0.852, acc=0.594, specificity=0.886, val_loss=1.02397776]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test model ResNet50Model - Loss: 1.01, ACC: 0.59, AUC: 0.85, Sensivility: 0.55, Specificity: 0.53\n"
     ]
    },
    {
     "data": {
      "image/png": "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cwbDhg1Dp06dUKlSJSQlJeHPP/+ETCZDhw4dsryHpaUlFi9ejGfPnqFSpUr466+/cPPmTWzatAmampoAgIEDB2Ljxo3w9PTEtWvXULZsWezduxfnz5/HqlWrYGBgkKPnSlWhQgVMnToVc+fOhbOzM3766SfI5XJcuXIFlpaWWLhwYbrva9OmDfbv34/27dujdevWePr0KTZs2IAqVarg8+fPinE///wzwsPD4ebmhpIlS+L58+f49ddfYWdnp1h/aPz48Th06BDatGkDT09P2NvbIzo6Grdv38bevXvx7NkzmJiY5Or5iAoSFnyIiIiIiOiHtmHDBtjb22Pjxo2YMmUKNDQ0ULZsWfTs2ROOjo6KcTNmzMDz58+xZMkSfPr0CS4uLjku+ABA//79YWZmhkWLFmHu3LnQ1NSEtbU1Ro8eDQCwtbVF8+bN8c8//yAkJAS6urqwtbXF0aNHUb9+/SyvX7RoUWzbtg3Dhw/H77//juLFi2Pt2rUYMGCAYoyOjg78/PwwadIkbNu2DVFRUahcuTK8vLzg6emZ42f62pw5c1CuXDn8+uuvmDp1KnR1dVGjRg306tUrw/d4enri7du32LhxI44fP44qVarA29sbe/bsgZ+fn2Jcz549sWnTJqxbtw4REREwNzdHly5dMGvWLMXUNF1dXfj7+2PBggXYs2cPtm/fDkNDQ1SqVAmzZ8/O1sLXRIWBRMisr46IiIiIiIgKDFdXV4SFheHOnTtih0JEIuMaPkREREREREREhQwLPkREREREREREhQwLPkREREREREREhQzX8CEiIiIiIiIiKmTY4UNEREREREREVMiw4ENEREREREREVMiw4ENERERERET5xtatWyGRSPDs2TOxQyEq0FjwISIiIiIitVu3bh0kEgnq1asndigF0vv37zFp0iRUr14d+vr60NbWRoUKFdC3b1+cO3dO7PDyneDgYLRo0QL6+vowNjZGr169EBoamq33li1bFhKJJM3rl19+STP25MmTcHJygq6uLooWLYqOHTuyUEX5hobYARARERERUeHn4+ODsmXL4vLly3j8+DEqVKggdkgFxuXLl9G6dWt8+vQJXbt2xS+//AK5XI6nT5/i77//xtatW+Hv74+GDRuKHWq+8OrVKzRs2BBGRkZYsGABPn/+jGXLluH27du4fPkytLS0sryGnZ0dxo4d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iIiIiIgKGe7SRUSFHpcqIyIiIiKiHw07fIiIiIiIiIiIChkWfIiIiIiIiIiIChkWfIiIiIiIiIiICplCuYaPTs1hYodQYN0/tVzsEAqs2IRksUMosEqb6IgdQoEllUjEDqHA0lbzv4Dq/rco9sZatV6fiIiIiAo2dvgQERERERERERUyhbLDh4iISHQS/p8KEREREYmHBR8iIiJ14HQ7IiIiIhIR//uRiIiIiIiIiKiQYYcPERGROnBKFxERERGJiD+NEhEREREREREVMuzwISIiUgeu4UNEREREImKHDxERERERERFRIcMOHyIiInXgGj5EREREJCL+NEpEREREREREVMiww4eIiEgduIYPEREREYmIBR8iIiJ14JQuIiIiIhIRfxolIiIiIiIiIipk2OFDRESkDpzSRUREREQiYocPEREREREREVEhww4fIiIideAaPkREREQkIv40SkRERERERERUyLDDh4iISB24hg8RERERiYgdPkREREREREREhQw7fIiIiNSBa/gQERERkYhY8CEiIlIHTukiIiIiIhHxvx+JiIiIiIiIiAoZdvgQERGpA6d0EREREZGI+NMoEREREREREVEhww4fIiIidWCHDxERERGJiD+NEhEREREREREVMuzwISIiUgcpd+kiIiIiIvGww4eIiIiIiIiIqJBhhw8REZE6cA0fIiIiIhIRCz5ERETqIOGULiIiIiISD//7kYiIiIiIiIiokGGHDxERkTpwShcRERERiYg/jRIRERERERERFTLs8CEiIlIHruFDRERERCJihw8RERERERERUSHDDh8iIiJ14Bo+RERERCQi/jRKRERERERERFTIsMOHiIhIHbiGDxERERGJiAUfIiIideCULiIiIiISEX8aJSIiIiIiIiIqZNjhowLj+jWDh5stKpUtjtj4RFwK+g9TVx/Eo+fvFWN+ndoVbvUqw8LUCJ9j43Ex6CmmrT6Ih8/eKca41q2EmUPaoGoFS0THJsDnn0uY+ds/SE5OEeOxRLFz+2ac9zuNly+eQktLjirV7fDzkFEoVaacYkz4hzD8vnYFrl+5gJiYaJQqXRbd+gyAc6OmIkYuvqMHd+Powb14//Y1AKB02fLo0mcg7Os5AQDehLyE1/qVCL59A4mJiahV1wEDR0xEEeNiYoadL235fSPOnDqJZ0//g1xbG7Z2NTFy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j2J9dqr1+h+2dVPr9YmIiIioYOMaPkREREREREREhQyndBEREalBflnDh4iIiIh+TOzwISIiIiIiIiIqZNjhQ0REpAbs8CEiIiIiMbHgQ0REpAYs+BARERGRmDili4iIiIiIiIiokGGHDxERkTqwwYeIiIiIRMQOHyIiIiIiIiKiQoYdPkRERGrANXyIiIiISEzs8CEiIiIiIiIiKmQKZYfPAe+ZYodQYGlrsgaYWx8+x4sdQoEl4WInVAixw4eIiIiIxMTf7omIiIiIiIiICplC2eFDREQkNnb4EBEREZGYWPAhIiJSAxZ8iIiIiEhMnNJFRERERERERFTIsMOHiIhIHdjgQ0REREQiYocPEREREREREVEhww4fIiIiNeAaPkREREQkJnb4EBEREREREREVMuzwISIiUgN2+BARERGRmNjhQ0RERERERERUyLDDh4iISA3Y4UNEREREYmLBh4iISB1Y7yEiIiIiEXFKFxERERERERFRIcMOHyIiIjXglC4iIiIiEhM7fIiIiIiIiIiIChl2+BAREakBO3yIiIiISEzs8CEiIiIiIiIiKmTY4UNERKQG7PAhIiIiIjGxw4eIiIiIiIiIqJBhhw8REZEasMOHiIiIiMTEgg8REZE6sN5DRERERCLilC4iIiIiIiIiokKGHT5ERERqwCldRERERCQmdvgQERERERERERUy7PAhIiJSA3b4EBEREZGY2OFDRERERERERFTIsMOHiIhIDdjgQ0RERERiYocPEREREREREVEhww4fIiIiNeAaPkREREQkJhZ8iIiI1ID1HiIiIiISE6d0EREREREREREVMuzwISIiUgNO6SIiIiIiMbHDh4iIiIiIiIiokGGHDxERkRqwwYeIiIiIxMQOHyIiIiIiIiKiQoYdPkRERGoglbLFh4iIiIjEww4fIiIiIiIiIqJChh0+REREasA1fIiIiIhITCz4EBERqQG3ZSciIiIiMXFKFxERERERERFRIcMOHzWYPagjwkPfpjnu1KI9Og0ci8ATB3Ht7Em8/O8h4mNjsPDPo9DVMxAh0vzn5vWr2PWnFx7cv4cPYaGYv3Q1nF0bK87HxMRg49qVOOd/BpGREbCwLIGOXXqgXYcuIkadP+zdvgn7vH9XOmZZsgyW/7EXAHD63/0473sczx4/QGxMNDbvPwM9fX7dZeTa1SvY5rUF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788NAAAAlzly5IiqV69+1WPmzJmjtWvXasyYMZo9e7YOHjyoSpUqKT09XWvWrFFAQICmTp2qUaNGKS0tTbGxsVq6dGmp80ydOlX16tVT1apVValSJaPekts5c+aMQkNDJV1qqOXm5pY65rPPPlPfvn1LHS+pVPOsvKKOzkEdneNqdWzQoIHS0tIkSatXr9aZM2ckSTk5OcrIyFC1atU0c+ZM14f2IL/3fZeUlKSRI0e6OtZ1o+EDAIABLBZjH4Cnql69ug4fPnzF/cXFxRo/frzatm2rKVOm6MiRI6pTp45atWqlAQMGaNKkSSouLtauXbuUnJys9u3b67PPPtOxY8dKnWvixInKycnR0aNHtXHjRiPfllsJDw/XuXPnJF1ap+Jy002ffPKJ/VKG/z1eknx9fV0T1M1RR+egjs5xtTr+5S9/UXZ2thISEhQcHKyoqChJUuXKlSVJ9913n7Zv3+760B7kat937733ni5evKgBAwaYEe260PABAACAy/To0UOff/65jh49KunSYqPbtm2z78/KytLZs2eVkZGhiRMnymazyWq1auTIkZo/f75Onjyp9evXKyYmRlOmTFF6ero2bdqkYcOGObyO1WqVdOmH9qCgoHI14dOqVSutXr1akrRy5Uq1bt3aYf/x48ftl89IUr169ZSdna0LFy7ou+++U2xsrMszuyPq6BzU0TmuVsfAwEC999579v333HOPCgoK7FMq69atU926dV0f2oNc6ftu9erV+vTTT+0LinsabssOAIABuJMWcHkRERGaNWuW+vXrJ5vNJl9fX7366qv2/TExMTpw4IA6d+6smJgYSdKBAwc0ZMgQe/OmadOmatiwoYYOHark5GRJ0iuvvKLmzZvbz5OSkqL09HRdvHhRHTp0KFe/NDZu3FiRkZFq06aNoqOjNXbsWA0bNkyzZ8+W5Hj5jHRpLYvRo0erffv2CggI0Pvvv29WdLdCHZ2DOjrH1eqYlZWl0aNHy8fHRwMHDlTt2rWVlZWlwYMHKzg4WDfccIM++OADs9+C2+nevbuysrK0Z88eDRs27LLfd8OGDVN4eLgSEhIUGBiob775xuTU18Zis9lsZodwtuyjBWZH8FghAfQAy2py2j6zI3is5zvXMzuCxwoNrGh2BI9ldOkmp+YYev5nOvFJHZxn27ZtatasmTIzM0stoIw/bsGCBRow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\n",
      "text/plain": [
       "<Figure size 1400x600 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Primera prueba para ver el entrenamiento\n",
    "# He probado antes en local para ver como alcanzaba un 100% de acc y 0.001 de loss con pocos datos\n",
    "train_model(model, trainer, train_dataset, val_dataset, epochs=30, device=device, save_model = \"experimento1.2\", name=\"!pretrain\", wdb=True, local=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "34a2939e",
   "metadata": {
    "papermill": {
     "duration": 1.455749,
     "end_time": "2025-03-05T15:05:16.273109",
     "exception": false,
     "start_time": "2025-03-05T15:05:14.817360",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 6786867,
     "sourceId": 10917159,
     "sourceType": "datasetVersion"
    },
    {
     "isSourceIdPinned": true,
     "modelId": 257789,
     "modelInstanceId": 236101,
     "sourceId": 275713,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 30919,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 11415.6099,
   "end_time": "2025-03-05T15:05:20.432253",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-03-05T11:55:04.822353",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
