{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "9c04790e",
   "metadata": {
    "papermill": {
     "duration": 0.003746,
     "end_time": "2025-03-05T08:05:33.177916",
     "exception": false,
     "start_time": "2025-03-05T08:05:33.174170",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "509cb204",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:33.185419Z",
     "iopub.status.busy": "2025-03-05T08:05:33.185130Z",
     "iopub.status.idle": "2025-03-05T08:05:41.485076Z",
     "shell.execute_reply": "2025-03-05T08:05:41.484140Z"
    },
    "papermill": {
     "duration": 8.305431,
     "end_time": "2025-03-05T08:05:41.486696",
     "exception": false,
     "start_time": "2025-03-05T08:05:33.181265",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import torch\n",
    "from PIL import Image\n",
    "from torchvision import transforms\n",
    "\n",
    "class HistogramEqualization:\n",
    "    \"\"\"Aplica ecualización de histograma para ajuste de contraste\"\"\"\n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar ecualización de histograma por canal\n",
    "        if len(img_np.shape) == 3:  # Imagen RGB\n",
    "            img_eq = np.zeros_like(img_np)\n",
    "            for i in range(3):\n",
    "                img_eq[:,:,i] = cv2.equalizeHist(img_np[:,:,i])\n",
    "        else:  # Imagen en escala de grises\n",
    "            img_eq = cv2.equalizeHist(img_np)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_eq)\n",
    "\n",
    "class BilateralFilter:\n",
    "    \"\"\"Aplica filtrado bilateral para suavizado preservando bordes\"\"\"\n",
    "    def __init__(self, d=9, sigma_color=75, sigma_space=75):\n",
    "        self.d = d  # Diámetro de cada vecindario de píxeles\n",
    "        self.sigma_color = sigma_color  # Filtro sigma en el espacio de color\n",
    "        self.sigma_space = sigma_space  # Filtro sigma en el espacio de coordenadas\n",
    "    \n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar filtro bilateral\n",
    "        img_filtered = cv2.bilateralFilter(\n",
    "            img_np, self.d, self.sigma_color, self.sigma_space)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_filtered)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "9bbe8377",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:41.494684Z",
     "iopub.status.busy": "2025-03-05T08:05:41.494289Z",
     "iopub.status.idle": "2025-03-05T08:05:41.505505Z",
     "shell.execute_reply": "2025-03-05T08:05:41.504825Z"
    },
    "papermill": {
     "duration": 0.016429,
     "end_time": "2025-03-05T08:05:41.506691",
     "exception": false,
     "start_time": "2025-03-05T08:05:41.490262",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "class DatasetExperiment1(Dataset):\n",
    "    def __init__(self, mode='train', batch_size=32, local = False, path = ''):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            mode (str): 'train', 'val' o 'test'.\n",
    "            transform: Transformaciones de torchvision a aplicar a las imágenes.\n",
    "        \"\"\"\n",
    "        assert mode in ['train', 'val', 'test'], \"Mode must be 'train', 'val', or 'test'\"\n",
    "        if local:\n",
    "            print(\"LOCAL MODE ENABLED\")\n",
    "\n",
    "        # Transformaciones del paper\n",
    "        # Histogram equalization for contrast adjustment\n",
    "        # and bilateral filtering for smoothness\n",
    "        self.transform =  transforms.Compose([\n",
    "            transforms.Resize((224, 224)),\n",
    "            HistogramEqualization(),\n",
    "            BilateralFilter(d=9, sigma_color=75, sigma_space=75),\n",
    "            transforms.ToTensor(),\n",
    "        ])\n",
    "        self.data_path = os.path.join(path, mode)\n",
    "        self.classes = sorted(os.listdir(self.data_path))  # Lista de clases\n",
    "        self.data = []\n",
    "        self.batch_size = batch_size\n",
    "        # Cargar imágenes con sus etiquetas\n",
    "        \n",
    "\n",
    "        for label, class_name in enumerate(self.classes):\n",
    "            class_path = os.path.join(self.data_path, class_name)\n",
    "            i = 0\n",
    "            for img_name in os.listdir(class_path):\n",
    "                if local and i >= 3:\n",
    "                    break\n",
    "                img_path = os.path.join(class_path, img_name)\n",
    "                self.data.append((img_path, label))\n",
    "                i += 1\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        img_path, label = self.data[idx]\n",
    "        image = Image.open(img_path).convert('RGB')\n",
    "\n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "        \n",
    "        return image, label\n",
    "    \n",
    "    def get_dataloader(self, shuffle=True):       \n",
    "        return DataLoader(self, batch_size=self.batch_size, shuffle=shuffle)\n",
    "    def show_image(self, idx, transformed=True, figsize=(10, 8)):\n",
    "        \"\"\"\n",
    "        Muestra una imagen del dataset con su etiqueta\n",
    "        \n",
    "        Args:\n",
    "            idx (int): Índice de la imagen a mostrar\n",
    "            transformed (bool): Si es True, muestra la imagen transformada. \n",
    "                               Si es False, muestra la imagen original.\n",
    "            figsize (tuple): Tamaño de la figura (ancho, alto)\n",
    "        \"\"\"\n",
    "        if idx >= len(self):\n",
    "            print(f\"Índice {idx} fuera de rango. El dataset tiene {len(self)} elementos.\")\n",
    "            return\n",
    "        \n",
    "        img_path, label = self.data[idx]\n",
    "        class_name = self.classes[label]\n",
    "        \n",
    "        plt.figure(figsize=figsize)\n",
    "        \n",
    "        # Mostrar imagen original\n",
    "        orig_img = Image.open(img_path).convert('RGB')\n",
    "        plt.subplot(1, 2, 1)\n",
    "        plt.imshow(orig_img)\n",
    "        plt.title(f\"Original: Clase {class_name} (label {label})\")\n",
    "        plt.axis('off')\n",
    "        \n",
    "        # Mostrar imagen transformada si se solicita\n",
    "        if transformed:\n",
    "            trans_img = self.transform(orig_img)\n",
    "            # Convertir tensor a numpy para visualización\n",
    "            if isinstance(trans_img, torch.Tensor):\n",
    "                trans_img = trans_img.permute(1, 2, 0).numpy()  # Cambiar de CxHxW a HxWxC\n",
    "                # Normalizar valores para visualización\n",
    "                trans_img = np.clip(trans_img, 0, 1)\n",
    "            \n",
    "            plt.subplot(1, 2, 2)\n",
    "            plt.imshow(trans_img)\n",
    "            plt.title(\"Con transformaciones aplicadas\")\n",
    "            plt.axis('off')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Imprimir información adicional\n",
    "        print(f\"Ruta de la imagen: {img_path}\")\n",
    "        print(f\"Clase: {class_name} (label {label})\")\n",
    "        print(f\"Resolución original: {orig_img.size}\")\n",
    "        if transformed and isinstance(trans_img, np.ndarray):\n",
    "            print(f\"Resolución después de transformaciones: {trans_img.shape[:2]}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "84f5e393",
   "metadata": {
    "papermill": {
     "duration": 0.003025,
     "end_time": "2025-03-05T08:05:41.512958",
     "exception": false,
     "start_time": "2025-03-05T08:05:41.509933",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train config 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eef98386",
   "metadata": {
    "papermill": {
     "duration": 0.002784,
     "end_time": "2025-03-05T08:05:41.518847",
     "exception": false,
     "start_time": "2025-03-05T08:05:41.516063",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The hyperparameters of the proposed ensemble model were\n",
    "tuned by the trial-and-error method. \n",
    "L2 regularization, \n",
    "batch normalization, \n",
    "dropout rate\n",
    "\n",
    "The Adam optimizer\n",
    "Epochs = 150. \n",
    "The learning rate scheduler and ReduceLROnPlateau were used for handling\n",
    "the learning rate with an initial value of 0.001. The loss\n",
    "function used for the model was categorical cross-entropy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f036d35",
   "metadata": {
    "papermill": {
     "duration": 0.002839,
     "end_time": "2025-03-05T08:05:41.524761",
     "exception": false,
     "start_time": "2025-03-05T08:05:41.521922",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Trainer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "151a9e96",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:41.532059Z",
     "iopub.status.busy": "2025-03-05T08:05:41.531772Z",
     "iopub.status.idle": "2025-03-05T08:05:50.326167Z",
     "shell.execute_reply": "2025-03-05T08:05:50.325418Z"
    },
    "papermill": {
     "duration": 8.800108,
     "end_time": "2025-03-05T08:05:50.327861",
     "exception": false,
     "start_time": "2025-03-05T08:05:41.527753",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install -q lightning\n",
    "import lightning.pytorch as pl\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torchmetrics as tm\n",
    "from torchmetrics.classification import MulticlassConfusionMatrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "class Classification(pl.LightningModule):\n",
    "    \"\"\"\n",
    "    Trainer para entrenar un modelo de clasificación multiclase\n",
    "    y de dimension 1 con valores [0, num_classes]\n",
    "    \"\"\"\n",
    "    def __init__(self, model, device, L1=0.001, L2=0.001, lr=0.001, patience=5, factor=0.1, betas=(0.9, 0.999)):\n",
    "        super().__init__()\n",
    "        self.save_hyperparameters(ignore=(\"model\",))\n",
    "\n",
    "        self.model = model\n",
    "\n",
    "        self.loss_fn = nn.CrossEntropyLoss()\n",
    "        self.L1 = L1\n",
    "        self.L2 = L2\n",
    "        self.learning_rate = lr\n",
    "        self.patience = patience\n",
    "        self.factor = factor\n",
    "        self.betas = betas\n",
    "\n",
    "        self.num_classes = 5\n",
    "        self.confusion_matrix = MulticlassConfusionMatrix(num_classes=5).to(device)\n",
    "        self.auc_metric = tm.AUROC(num_classes=5, task=\"multiclass\").to(device)  # Definir métrica AUROC para clasificación multiclase\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.model(x)\n",
    "\n",
    "    def training_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        \n",
    "        # Regularización L1\n",
    "        L1_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L1_reg = L1_reg + torch.sum(torch.abs(param))\n",
    "        \n",
    "        # Regularización L2\n",
    "        L2_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L2_reg = L2_reg + torch.sum(param ** 2)\n",
    "        \n",
    "        # Añadir regularización a la pérdida\n",
    "        prediction_loss = loss\n",
    "        loss = loss + self.L1 * L1_reg + self.L2 * L2_reg\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        loss.backward()\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "\n",
    "        return {\"loss\": prediction_loss, \"real_loss\": loss, \"ACC\": ACC, \"recall\": recall, \"precision\": precision, \"f1_score\": f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def validation_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "        return {\"loss\": loss, \"ACC\": ACC, \"precision\" : precision, \"recall\": recall, \"f1_score\" : f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def transform_classes(self, y):\n",
    "        # Convertir las clases a un formato de one-hot encoding\n",
    "        return torch.nn.functional.one_hot(y.to(torch.int64), num_classes=5).to(float).squeeze()\n",
    "    def restart_epoch(self, plot = False):\n",
    "        if plot:\n",
    "            self.plot()\n",
    "        self.confusion_matrix.reset()\n",
    "        self.auc_metric.reset()\n",
    "    def calculate_metrics_from_confusion_matrix(self):\n",
    "        # Obtener la matriz de confusión (suponiendo que es un tensor de torch)\n",
    "        cm = self.confusion_matrix.compute()\n",
    "        total_samples = cm.sum()\n",
    "        \n",
    "        # Verdaderos positivos por clase (diagonal de la matriz)\n",
    "        true_positives = torch.diag(cm)\n",
    "        \n",
    "        # Predicciones totales por clase (sumar columnas)\n",
    "        predicted_positives = cm.sum(dim=0)\n",
    "        \n",
    "        # Ejemplos reales por clase (sumar filas)\n",
    "        actual_positives = cm.sum(dim=1)\n",
    "        \n",
    "        # Calcular falsos positivos y falsos negativos por clase\n",
    "        false_positives = predicted_positives - true_positives\n",
    "        false_negatives = actual_positives - true_positives\n",
    "        \n",
    "        # Calcular verdaderos negativos por clase\n",
    "        true_negatives = total_samples - (actual_positives + predicted_positives - true_positives)\n",
    "        \n",
    "        # Calcular métricas por clase con robustez para evitar división por cero\n",
    "        precision_per_class = true_positives / (predicted_positives + 1e-8)\n",
    "        recall_per_class = true_positives / (actual_positives + 1e-8)\n",
    "        specificity_per_class = true_negatives / (true_negatives + false_positives + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Promediar las métricas por clase\n",
    "        precision = precision_per_class.mean()\n",
    "        recall = recall_per_class.mean()\n",
    "        specificity = specificity_per_class.mean()\n",
    "        f1 = f1_per_class.mean()\n",
    "        \n",
    "        # Calcular Accuracy (exactitud)\n",
    "        ACC = true_positives.sum() / total_samples\n",
    "        \n",
    "        # Calcular el AUC (suponiendo que self.auc_metric ya está correctamente definido)\n",
    "        AUC = self.auc_metric.compute()\n",
    "        \n",
    "        return precision, recall, f1, ACC, AUC, specificity\n",
    "\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        optimizer = torch.optim.Adam(self.model.parameters(),\n",
    "                                     lr=self.learning_rate,\n",
    "                                     betas=self.betas)\n",
    "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer,\n",
    "                                                               factor=self.factor,\n",
    "                                                               patience=self.patience)\n",
    "        return optimizer, scheduler\n",
    "    def plot(self, epoch=0):\n",
    "        # Computa la matriz de confusión y las métricas por clase\n",
    "        cm = self.confusion_matrix.compute().cpu().numpy()\n",
    "        support = cm.sum(axis=1)\n",
    "        precision_per_class = np.diag(cm) / (cm.sum(axis=0) + 1e-8)\n",
    "        recall_per_class = np.diag(cm) / (cm.sum(axis=1) + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Cálculo de especificidad por clase\n",
    "        FP = cm.sum(axis=0) - np.diag(cm)\n",
    "        FN = cm.sum(axis=1) - np.diag(cm)\n",
    "        TN = cm.sum() - (FP + FN + np.diag(cm))\n",
    "        specificity_per_class = TN / (TN + FP + 1e-8)\n",
    "        \n",
    "        accuracy = np.diag(cm).sum() / cm.sum()\n",
    "\n",
    "        # Crea dos subplots: uno para la matriz de confusión y otro para la tabla de métricas\n",
    "        fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "        # Subplot 1: Matriz de confusión con heatmap\n",
    "        sns.heatmap(cm, annot=True, fmt=\"d\", ax=axs[0], cmap=\"Blues\")\n",
    "        axs[0].set_title(\"Matriz de Confusión epoch \" + str(epoch))\n",
    "        axs[0].set_xlabel(\"Predicción\")\n",
    "        axs[0].set_ylabel(\"Real\")\n",
    "\n",
    "        # Subplot 2: Tabla de métricas por clase\n",
    "        table_data = []\n",
    "        for i in range(self.num_classes):\n",
    "            table_data.append([f\"Clase {i}\",\n",
    "                            f\"{precision_per_class[i]:.2f}\",\n",
    "                            f\"{recall_per_class[i]:.2f}\",\n",
    "                            f\"{f1_per_class[i]:.2f}\",\n",
    "                            f\"{specificity_per_class[i]:.2f}\",\n",
    "                            int(support[i])])\n",
    "        axs[1].axis('tight')\n",
    "        axs[1].axis('off')\n",
    "        table = axs[1].table(cellText=table_data,\n",
    "                            colLabels=[\"Clase\", \"Precision\", \"Sensivity/Recall\", \"F1\", \"Specificity\", \"Support\"],\n",
    "                            cellLoc=\"center\", loc=\"center\")\n",
    "        axs[1].set_title(f\"Metrics por clase\\nAccuracy General: {accuracy:.2f}\", pad=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f44c3d2f",
   "metadata": {
    "papermill": {
     "duration": 0.003062,
     "end_time": "2025-03-05T08:05:50.334473",
     "exception": false,
     "start_time": "2025-03-05T08:05:50.331411",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "a1877156",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:50.342094Z",
     "iopub.status.busy": "2025-03-05T08:05:50.341691Z",
     "iopub.status.idle": "2025-03-05T08:05:50.348330Z",
     "shell.execute_reply": "2025-03-05T08:05:50.347703Z"
    },
    "papermill": {
     "duration": 0.011836,
     "end_time": "2025-03-05T08:05:50.349455",
     "exception": false,
     "start_time": "2025-03-05T08:05:50.337619",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.nn import functional as F\n",
    "import torchvision.models as models\n",
    "\n",
    "class ResNet50Model(nn.Module):\n",
    "    \"\"\"\n",
    "    Modelo basado en ResNet50 para la clasificación de radiografías.\n",
    "    Permite personalización en el número de clases y si se usa transfer learning.\n",
    "    \"\"\"\n",
    "    def __init__(self, num_classes=5, pretrained=True, freeze_backbone=False, dropout_rate=0.3):\n",
    "        \"\"\"\n",
    "        Inicializa el modelo ResNet50.\n",
    "        \n",
    "        Args:\n",
    "            num_classes (int): Número de clases para la clasificación (default: 5)\n",
    "            pretrained (bool): Si se deben usar pesos preentrenados en ImageNet (default: True)\n",
    "            freeze_backbone (bool): Si se deben congelar las capas de la red base (default: False)\n",
    "            dropout_rate (float): Tasa de dropout aplicada antes de la capa de clasificación (default: 0.3)\n",
    "        \"\"\"\n",
    "        super(ResNet50Model, self).__init__()\n",
    "        \n",
    "        # Cargar el modelo base ResNet50\n",
    "        self.model = models.resnet50(weights='IMAGENET1K_V2' if pretrained else None)\n",
    "        \n",
    "        # Nombre del modelo para identificación\n",
    "        self.name = \"ResNet50\"\n",
    "        \n",
    "        # Congelar los parámetros de la red si se especifica\n",
    "        if freeze_backbone:\n",
    "            for param in self.model.parameters():\n",
    "                param.requires_grad = False\n",
    "        \n",
    "        # Reemplazar la capa de clasificación final\n",
    "        in_features = self.model.fc.in_features\n",
    "        self.model.fc = nn.Sequential(\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(in_features, 512),\n",
    "            nn.ReLU(),\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(512, num_classes)\n",
    "        )\n",
    "    \n",
    "    def forward(self, x):\n",
    "        \"\"\"\n",
    "        Propagación hacia adelante a través del modelo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor con las predicciones de clase [batch_size, num_classes]\n",
    "        \"\"\"\n",
    "        return self.model(x)\n",
    "    \n",
    "    def get_features(self, x):\n",
    "        \"\"\"\n",
    "        Obtiene los features del modelo antes de la capa de clasificación.\n",
    "        Útil para análisis de características o transferencia de estilo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor de características [batch_size, 2048]\n",
    "        \"\"\"\n",
    "        # Extrae todas las capas excepto la final\n",
    "        modules = list(self.model.children())[:-1]\n",
    "        feature_extractor = nn.Sequential(*modules)\n",
    "        \n",
    "        # Obtiene los features y los aplana\n",
    "        features = feature_extractor(x)\n",
    "        features = features.view(features.size(0), -1)\n",
    "        \n",
    "        return features\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "05aa6572",
   "metadata": {
    "papermill": {
     "duration": 0.002861,
     "end_time": "2025-03-05T08:05:50.355481",
     "exception": false,
     "start_time": "2025-03-05T08:05:50.352620",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "ba4fd050",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:50.362536Z",
     "iopub.status.busy": "2025-03-05T08:05:50.362301Z",
     "iopub.status.idle": "2025-03-05T08:05:52.240388Z",
     "shell.execute_reply": "2025-03-05T08:05:52.239696Z"
    },
    "papermill": {
     "duration": 1.883605,
     "end_time": "2025-03-05T08:05:52.242185",
     "exception": false,
     "start_time": "2025-03-05T08:05:50.358580",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "from tqdm import tqdm\n",
    "from wandb import wandb\n",
    "\n",
    "def create_tqdm_bar(iterable, desc, mode):\n",
    "    return tqdm(enumerate(iterable),total=len(iterable), ncols=200, desc=desc)\n",
    "\n",
    "def train_model(model, trainer, train_dataset, val_dataset, epochs=5, transform=None, device='cuda', save_model = \"\", name=\"Test\", wdb=True, local=False, project=\"oai-knee-cartilage-segmentation\"):\n",
    "    if wdb:\n",
    "        if wandb.run is not None:\n",
    "            wandb.finish()\n",
    "        wandb.init(\n",
    "            project=project,\n",
    "            name=name,\n",
    "            # track hyperparameters and run metadata\n",
    "            config={\n",
    "                \"model\": model.name,\n",
    "                \"Batch_size\": train_dataset.batch_size,\n",
    "                \"learning_rate\": trainer.learning_rate,\n",
    "                \"L1\": trainer.L1,\n",
    "                \"L2\": trainer.L2,\n",
    "                \"patience\": trainer.patience,\n",
    "                \"factor\": trainer.factor,\n",
    "                \"betas\": trainer.betas,\n",
    "                \"epochs\": epochs,\n",
    "            }\n",
    "        )\n",
    "    train_loader = train_dataset.get_dataloader(shuffle=True)\n",
    "    val_loader = val_dataset.get_dataloader(shuffle=True)\n",
    "    model.to(device)\n",
    "    train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = local, save_model = save_model)\n",
    "    \n",
    "\n",
    "def train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = False, save_model = \"\"):\n",
    "    \"\"\"\n",
    "    train the given model\n",
    "    \"\"\"\n",
    "    optimizer, scheduler = trainer.configure_optimizers()\n",
    "    best_model = None\n",
    "    best_loss = float('inf')\n",
    "    for epoch in range(epochs):        \n",
    "        training_loss = []\n",
    "        validation_loss = []\n",
    "\n",
    "        training_loss_num = 0\n",
    "        complete_loss_num = 0\n",
    "        validation_loss_num = 0\n",
    "\n",
    "        # use training data\n",
    "        model.train()\n",
    "\n",
    "        training_loop = create_tqdm_bar(train_loader, desc=f'Training Epoch [{epoch + 1}/{epochs}]', mode='train')\n",
    "        for train_iteration, batch in training_loop:\n",
    "            batch = batch[0].to(device), batch[1].to(device)\n",
    "            optimizer.zero_grad()\n",
    "            res = trainer.training_step(batch[0], batch[1])\n",
    "            optimizer.step()\n",
    "\n",
    "            training_loss.append(res['loss'].item())\n",
    "            training_loss_num += res['loss'].item()\n",
    "            complete_loss_num += res['real_loss'].item()\n",
    "            # Update the progress bar.\n",
    "            training_loop.set_postfix(train_loss=\"{:.4f}\".format(training_loss_num / (train_iteration + 1)),\n",
    "                                      complete_loss=\"{:.4f}\".format(complete_loss_num / (train_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      sensivity=res['recall'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "            if wdb:\n",
    "                \n",
    "                wandb.log({\"train_loss\": training_loss_num / (train_iteration + 1),\n",
    "                           \"complete_loss\": complete_loss_num / (train_iteration + 1),\n",
    "                        \"train_acc\": res['ACC'],\n",
    "                        \"train_recall\": res['recall'].item(),\n",
    "                        \"train_precision\": res['precision'].item(),\n",
    "                        \"train_specifity\": res['specificity'].item(),\n",
    "                        \"train_f1_score\": res['f1_score'].item(),\n",
    "                        \"train_AUC\": res['AUC'],\n",
    "                        \"epoch\": epoch,\n",
    "                        \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        trainer.restart_epoch(plot=False)\n",
    "        # use validation data\n",
    "        if local:\n",
    "            continue\n",
    "        model.eval()\n",
    "        val_loop = create_tqdm_bar(val_loader, desc=f'Validation Epoch [{epoch + 1}/{epochs}]', mode='val')\n",
    "        with torch.no_grad():\n",
    "            for val_iteration, batch in val_loop:\n",
    "                batch = batch[0].to(device), batch[1].to(device)\n",
    "                res = trainer.validation_step(batch[0], batch[1])  \n",
    "                validation_loss.append(res['loss'].item())\n",
    "                validation_loss_num += res['loss'].item()\n",
    "                val_loop.set_postfix(val_loss = \"{:.8f}\".format(validation_loss_num / (val_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "                                      \n",
    "        if wdb:\n",
    "            wandb.log({\"val_loss\": validation_loss_num / (val_iteration + 1),\n",
    "                    \"val_acc\": res['ACC'],\n",
    "                    \"val_recall\": res['recall'].item(),\n",
    "                    \"val_precision\": res['precision'].item(),\n",
    "                    \"val_specificity\": res['specificity'].item(),\n",
    "                    \"val_f1_score\": res['f1_score'].item(),\n",
    "                    \"val_AUC\": res['AUC'],\n",
    "                    \"epoch\": epoch,\n",
    "                    \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        if validation_loss_num < best_loss:\n",
    "            best_loss = validation_loss_num\n",
    "            if save_model != \"\":\n",
    "                torch.save(model.state_dict(), f\"best_model_{model.__class__.__name__}_{save_model}_epoch_{epoch}.pt\")\n",
    "        scheduler.step(res['loss'].item())\n",
    "        trainer.restart_epoch(plot=False)\n",
    "    \n",
    "    test_model(model, val_loader, trainer, device, wdb)\n",
    "\n",
    "def test_model(model, test_loader, trainer, device, wdb=False):\n",
    "    \"\"\"\n",
    "    Test the given model\n",
    "    \"\"\"\n",
    "    model.eval()\n",
    "    model.to(device)\n",
    "\n",
    "    epoch_loss = 0.0\n",
    "    avg_loss = 0.0\n",
    "    trainer.restart_epoch(plot = False)\n",
    "    for batch in test_loader:\n",
    "        inputs, labels = batch\n",
    "        inputs = inputs.to(device)\n",
    "        \n",
    "        labels = labels.to(device)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            res = trainer.validation_step(inputs, labels)\n",
    "            # Extraer valores escalares\n",
    "            loss = res['loss']\n",
    "            \n",
    "        loss_value = loss.item()\n",
    "        # Calcular promedios\n",
    "        epoch_loss += loss_value\n",
    "\n",
    "    ACC_value = res['ACC']\n",
    "    recall_value = res['recall'].item()\n",
    "    precision_value = res['precision'].item()\n",
    "    f1_score_value = res['f1_score'].item()\n",
    "    AUC_value = res['AUC']\n",
    "    avg_loss = epoch_loss / len(test_loader)\n",
    "    if wdb:\n",
    "        wandb.log({\"test_loss\": avg_loss, \"test_acc\": ACC_value.item(),\n",
    "                \"test_recall\": recall_value, \"test_precision\": precision_value,\n",
    "                \"test_f1_score\": f1_score_value, \"test_AUC\" : AUC_value})\n",
    "    \n",
    "    print(f\"Test model {model.__class__.__name__} - Loss: {avg_loss:.2f}, ACC: {ACC_value:.2f}, AUC: {AUC_value:.2f}, Sensivility: {recall_value:.2f}, Specificity: {precision_value:.2f}\")\n",
    "\n",
    "    trainer.restart_epoch(plot = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "ab6a56f4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:52.249687Z",
     "iopub.status.busy": "2025-03-05T08:05:52.249403Z",
     "iopub.status.idle": "2025-03-05T08:05:53.271966Z",
     "shell.execute_reply": "2025-03-05T08:05:53.270992Z"
    },
    "papermill": {
     "duration": 1.028042,
     "end_time": "2025-03-05T08:05:53.273635",
     "exception": false,
     "start_time": "2025-03-05T08:05:52.245593",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import os\n",
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "BATCH_SIZE = 64\n",
    "LEARNING_RATE = 0.001\n",
    "FACTOR = 0.1\n",
    "L1 = 0.00\n",
    "L2 = 0.0001\n",
    "PATIENCE = 5\n",
    "BETAS=(0.9, 0.999)\n",
    "DATASET_PATH = '/kaggle/input/aug-oai-capitulo3/augmented_oai'\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "train_dataset = DatasetExperiment1('train', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "val_dataset = DatasetExperiment1('val', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "model = ResNet50Model(num_classes=len(train_dataset.classes), dropout_rate=0.5, pretrained = False)\n",
    "trainer = Classification(model, device, L1=L1, L2=L2, lr=LEARNING_RATE, patience=PATIENCE, factor=FACTOR, betas=BETAS)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "2a058abb",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:53.281433Z",
     "iopub.status.busy": "2025-03-05T08:05:53.281181Z",
     "iopub.status.idle": "2025-03-05T08:05:54.294705Z",
     "shell.execute_reply": "2025-03-05T08:05:54.293907Z"
    },
    "papermill": {
     "duration": 1.018969,
     "end_time": "2025-03-05T08:05:54.296041",
     "exception": false,
     "start_time": "2025-03-05T08:05:53.277072",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Using wandb-core as the SDK backend.  Please refer to https://wandb.me/wandb-core for more information.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33mchermar\u001b[0m (\u001b[33mchermar-universitat-polit-cnica-de-val-ncia\u001b[0m). Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m If you're specifying your api key in code, ensure this code is not shared publicly.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m Consider setting the WANDB_API_KEY environment variable, or running `wandb login` from the command line.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Appending key for api.wandb.ai to your netrc file: /root/.netrc\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wandb.login(key=\"254f72e7bdeec44797ba1b2a91ebbc63900b89f4\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "3f9af5cc",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T08:05:54.304106Z",
     "iopub.status.busy": "2025-03-05T08:05:54.303872Z",
     "iopub.status.idle": "2025-03-05T10:49:50.156885Z",
     "shell.execute_reply": "2025-03-05T10:49:50.156041Z"
    },
    "papermill": {
     "duration": 9836.347077,
     "end_time": "2025-03-05T10:49:50.646793",
     "exception": false,
     "start_time": "2025-03-05T08:05:54.299716",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Tracking run with wandb version 0.19.1\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run data is saved locally in \u001b[35m\u001b[1m/kaggle/working/wandb/run-20250305_080554-qqb4fo3k\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run \u001b[1m`wandb offline`\u001b[0m to turn off syncing.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Syncing run \u001b[33m!pretrain\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: ⭐️ View project at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: 🚀 View run at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation/runs/qqb4fo3k\u001b[0m\n",
      "Training Epoch [1/20]:   0%|                                                                                                                                                    | 0/459 [00:00<?, ?it/s]/usr/local/lib/python3.10/dist-packages/torchmetrics/utilities/prints.py:43: UserWarning: No positive samples in targets, true positive value should be meaningless. Returning zero tensor in true positive score\n",
      "  warnings.warn(*args, **kwargs)  # noqa: B028\n",
      "Training Epoch [1/20]: 100%|████████████████████████████████████████| 459/459 [10:26<00:00,  1.37s/it, AUC=0.64, acc=0.416, complete_loss=5.4311, sensivity=0.246, specificity=0.818, train_loss=1.3521]\n",
      "Validation Epoch [1/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:12<00:00,  1.03it/s, AUC=0.714, acc=0.388, specificity=0.831, val_loss=1.37137105]\n",
      "Training Epoch [2/20]: 100%|████████████████████████████████████████| 459/459 [07:48<00:00,  1.02s/it, AUC=0.725, acc=0.474, complete_loss=2.6645, sensivity=0.323, specificity=0.84, train_loss=1.2186]\n",
      "Validation Epoch [2/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.31it/s, AUC=0.738, acc=0.441, specificity=0.825, val_loss=1.26159505]\n",
      "Training Epoch [3/20]: 100%|███████████████████████████████████████| 459/459 [07:50<00:00,  1.03s/it, AUC=0.749, acc=0.497, complete_loss=1.8713, sensivity=0.352, specificity=0.848, train_loss=1.1711]\n",
      "Validation Epoch [3/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.32it/s, AUC=0.666, acc=0.403, specificity=0.805, val_loss=1.77186836]\n",
      "Training Epoch [4/20]: 100%|████████████████████████████████████████| 459/459 [08:05<00:00,  1.06s/it, AUC=0.763, acc=0.51, complete_loss=1.5652, sensivity=0.365, specificity=0.852, train_loss=1.1406]\n",
      "Validation Epoch [4/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:10<00:00,  1.29it/s, AUC=0.695, acc=0.336, specificity=0.825, val_loss=1.40597043]\n",
      "Training Epoch [5/20]: 100%|███████████████████████████████████████| 459/459 [07:59<00:00,  1.05s/it, AUC=0.777, acc=0.525, complete_loss=1.4184, sensivity=0.379, specificity=0.857, train_loss=1.1117]\n",
      "Validation Epoch [5/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.30it/s, AUC=0.755, acc=0.415, specificity=0.845, val_loss=1.27201059]\n",
      "Training Epoch [6/20]: 100%|███████████████████████████████████████| 459/459 [07:57<00:00,  1.04s/it, AUC=0.789, acc=0.538, complete_loss=1.3340, sensivity=0.391, specificity=0.862, train_loss=1.0851]\n",
      "Validation Epoch [6/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.764, acc=0.509, specificity=0.848, val_loss=1.14239199]\n",
      "Training Epoch [7/20]: 100%|███████████████████████████████████████| 459/459 [08:03<00:00,  1.05s/it, AUC=0.795, acc=0.547, complete_loss=1.2801, sensivity=0.401, specificity=0.865, train_loss=1.0660]\n",
      "Validation Epoch [7/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.30it/s, AUC=0.748, acc=0.404, specificity=0.838, val_loss=1.32864713]\n",
      "Training Epoch [8/20]: 100%|████████████████████████████████████████| 459/459 [08:02<00:00,  1.05s/it, AUC=0.803, acc=0.557, complete_loss=1.2370, sensivity=0.41, specificity=0.867, train_loss=1.0458]\n",
      "Validation Epoch [8/20]: 100%|█████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.37it/s, AUC=0.807, acc=0.55, specificity=0.859, val_loss=1.09834643]\n",
      "Training Epoch [9/20]: 100%|███████████████████████████████████████| 459/459 [08:01<00:00,  1.05s/it, AUC=0.811, acc=0.561, complete_loss=1.2030, sensivity=0.421, specificity=0.868, train_loss=1.0262]\n",
      "Validation Epoch [9/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.32it/s, AUC=0.806, acc=0.519, specificity=0.865, val_loss=1.12802977]\n",
      "Training Epoch [10/20]: 100%|█████████████████████████████████████████| 459/459 [08:00<00:00,  1.05s/it, AUC=0.842, acc=0.6, complete_loss=1.1080, sensivity=0.473, specificity=0.88, train_loss=0.9390]\n",
      "Validation Epoch [10/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.36it/s, AUC=0.849, acc=0.614, specificity=0.887, val_loss=0.90980648]\n",
      "Training Epoch [11/20]: 100%|██████████████████████████████████████| 459/459 [07:54<00:00,  1.03s/it, AUC=0.852, acc=0.616, complete_loss=1.0721, sensivity=0.515, specificity=0.886, train_loss=0.9065]\n",
      "Validation Epoch [11/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.851, acc=0.624, specificity=0.885, val_loss=0.93219769]\n",
      "Training Epoch [12/20]: 100%|███████████████████████████████████████| 459/459 [07:50<00:00,  1.02s/it, AUC=0.86, acc=0.627, complete_loss=1.0442, sensivity=0.538, specificity=0.889, train_loss=0.8813]\n",
      "Validation Epoch [12/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.854, acc=0.619, specificity=0.886, val_loss=0.91599410]\n",
      "Training Epoch [13/20]: 100%|██████████████████████████████████████| 459/459 [07:48<00:00,  1.02s/it, AUC=0.865, acc=0.637, complete_loss=1.0256, sensivity=0.553, specificity=0.892, train_loss=0.8645]\n",
      "Validation Epoch [13/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.40it/s, AUC=0.862, acc=0.614, specificity=0.883, val_loss=0.88918314]\n",
      "Training Epoch [14/20]: 100%|██████████████████████████████████████| 459/459 [07:48<00:00,  1.02s/it, AUC=0.872, acc=0.645, complete_loss=1.0003, sensivity=0.566, specificity=0.894, train_loss=0.8405]\n",
      "Validation Epoch [14/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.37it/s, AUC=0.858, acc=0.636, specificity=0.891, val_loss=0.92770559]\n",
      "Training Epoch [15/20]: 100%|██████████████████████████████████████| 459/459 [07:53<00:00,  1.03s/it, AUC=0.879, acc=0.654, complete_loss=0.9763, sensivity=0.578, specificity=0.897, train_loss=0.8173]\n",
      "Validation Epoch [15/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.36it/s, AUC=0.86, acc=0.637, specificity=0.892, val_loss=0.88283417]\n",
      "Training Epoch [16/20]: 100%|██████████████████████████████████████| 459/459 [07:48<00:00,  1.02s/it, AUC=0.886, acc=0.667, complete_loss=0.9517, sensivity=0.597, specificity=0.901, train_loss=0.7932]\n",
      "Validation Epoch [16/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:10<00:00,  1.29it/s, AUC=0.861, acc=0.623, specificity=0.884, val_loss=0.91397943]\n",
      "Training Epoch [17/20]: 100%|██████████████████████████████████████| 459/459 [07:46<00:00,  1.02s/it, AUC=0.892, acc=0.678, complete_loss=0.9255, sensivity=0.612, specificity=0.905, train_loss=0.7669]\n",
      "Validation Epoch [17/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.33it/s, AUC=0.86, acc=0.618, specificity=0.888, val_loss=0.88715826]\n",
      "Training Epoch [18/20]: 100%|████████████████████████████████████████| 459/459 [07:45<00:00,  1.01s/it, AUC=0.9, acc=0.687, complete_loss=0.8984, sensivity=0.618, specificity=0.908, train_loss=0.7398]\n",
      "Validation Epoch [18/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.36it/s, AUC=0.863, acc=0.64, specificity=0.892, val_loss=0.93153015]\n",
      "Training Epoch [19/20]: 100%|██████████████████████████████████████| 459/459 [07:47<00:00,  1.02s/it, AUC=0.909, acc=0.701, complete_loss=0.8634, sensivity=0.637, specificity=0.913, train_loss=0.7044]\n",
      "Validation Epoch [19/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.859, acc=0.609, specificity=0.889, val_loss=0.98857477]\n",
      "Training Epoch [20/20]: 100%|███████████████████████████████████████| 459/459 [07:45<00:00,  1.01s/it, AUC=0.916, acc=0.714, complete_loss=0.8324, sensivity=0.66, specificity=0.918, train_loss=0.6728]\n",
      "Validation Epoch [20/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.86, acc=0.609, specificity=0.887, val_loss=1.00692983]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test model ResNet50Model - Loss: 1.04, ACC: 0.61, AUC: 0.86, Sensivility: 0.58, Specificity: 0.63\n"
     ]
    },
    {
     "data": {
      "image/png": "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LCt8iIiIRCfh31SIiIiISDwc8CEiIlIFzrcjIiIiIhHxz49ERERERERERMUMK3yIiIhUgVO6iIiIiEhE/DRKRERERERERFTMsMKHiIhIFbiGDxERERGJiBU+RERERERERETFDCt8iIiIVIFr+BARERGRiPhplIiIiIiIiIiomGGFDxERkSpwDR8iIiIiEhEHfIiIiFSBU7qIiIiISET8NEpEREREREREVMywwoeIiEgVOKWLiIiIiETECh8iIiIiIiIiomKGFT5ERESqwDV8iIiIiEhE/DRKRERERERERFTMsMKHiIhIFbiGDxERERGJiBU+RERERERERETFDCt8iIiIVIFr+BARERGRiDjgQ0REpAqc0kVEREREIuKfH4mIiIiIiIiIihlW+BAREakCp3QRERERkYj4aZSIiIiIiIiIqJhhhQ8REZEqsMKHiIiIiETET6NERERERERERMUMK3yIiIhUQY27dBERERGReFjhQ0RERERERERUzLDCh4iISBW4hg8RERERiYgDPkRERKog4ZQuIiIiIhIP//xIRERERERERFTMsMKHiIhIFTili4iIiIhExE+jRERERERERETFDCt8iIiIVIFr+BARERGRiFjhQ0RERERERERUzLDCh4iISBW4hg8RERERiYifRomIiIiIiIiIihlW+BAREakC1/AhIiIiIhFxwIeIiEgVOKWLiIiIiETET6NERERERERERMUMK3yUYNKgtnBxrIfqlU2QkJSCK4H/Yeaaw3gS8l7eZ93MXnBsWgOmxgaITUjC5cBgzFpzGI+fv5P3+X1Kd1jX+wG1qpriYfA7WPdaIsbtiOrIwX04emgf3r15DQCoVMUcfdyGoXGz5gCA5KQk/Ln+d/idPYGUlGRYNbHByIkzUcqwtJhhFzqH9nhg97b16NC1N9xGTJS3P35wB3u2b8DTh/egpiZFZfPqmLlkHTRlWiJGWzjduH4NO9y3IejBPYSFhWHlmj/g2Kq12GEVGXt3e2KH+zaEh4eheg0LTJsxG3Xq1hU7rILFKV1EREREJCJW+CiBXcOq2PS3P+z7r0Cn4euhri7FkY2joKOlKe9zK+glhv66C/W7LkTnEX9AIpHgyIaRUFNT/IVg5+HL8D51s6BvodAwMi6Dgb+Mxbpte7B2627Ua9gE86ePRch/TwEAm9ctx5WLfpixYDmWrduO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ga8ZlFGlkSNHYvfu3Th8+DD09fXla+4YGBhAW1sbBgYGGDx4MCZMmABDQ0OUKFECo0ePRrNmzWBtbQ0AaNu2LWrWrAlXV1csW7YMb9++xaxZszBy5MivqjIiIiIiooLDAR8iIqJibOPGjQAABwcHhXZ3d3e4ubkBAFatWgU1NTV069YNSUlJaNeuHTZs2CDvK5VKceTIEQwfPhzNmjWDrq4uBgwYgPnz5xfUbRARERHRV5IIgiCIHYSyaTcYJXYIRdb9UyvEDqHIiklMETuEIqt6WX2xQyiyCkkRSZGkpeI/eZTotVOl54/e21+l5yciIiKioo1r+BARERERERERFTOc0kVERKQChWUNHyIiIiL6PrHCh4iIiIiIiIiomGGFDxERkSqwwIeIiIiIRMQKHyIiIiIiIiKiYoYVPkRERCrANXyIiIiISEys8CEiIiIiIiIiKmZY4UNERKQCrPAhIiIiIjFxwIeIiEgFOOBDRERERGLilC4iIiIiIiIiomKGFT5EREQqwAofIiIiIhITK3yIiIiIiIiIiIoZVvgQERGpAgt8iIiIiEhErPAhIiIiIiIiIipmWOFDRESkAlzDh4iIiIjExAofIiIiIiIiIqJihhU+REREKsAKHyIiIiISEwd8iIiIVIADPkREREQkJk7pIiIiIiIiIiIqZljhQ0REpAos8CEiIiIiEbHCh4iIiIiIiIiomGGFDxERkQpwDR8iIiIiEhMrfIiIiIiIiIiIipliWeHj/dccsUMosjTVOQZIRKQMrPAhIiIiIjHxt3siIiIiIiIiomKmWFb4EBERiY0VPkREREQkJg74EBERqQAHfIiIiIhITJzSRURERERERERUzLDCh4iISBVY4ENEREREImKFDxERERERERFRMcMKHyIiIhXgGj5EREREJCZW+BARERERERERFTOs8CEiIlIBVvgQERERkZhY4UNEREREREREVMywwoeIiEgFWOFDRERERGLigA8REZEqcLyHiIiIiETEKV1ERERERERERMUMK3yIiIhUgFO6iIiIiEhMrPAhIiIiIiIiIipmWOFDRESkAqzwISIiIiIxscKHiIiIiIiIiKiYYYUPERGRCrDCh4iIiIjExAofIiIiIiIiIqJihhU+REREKsAKHyIiIiISEwd8iIiIVIHjPUREREQkIk7pIiIiIiIiIiIqZljhQ0RE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DRvw448/Znn89u3bsLKyKuColOPJnev4GP4OTVplnmIUcOowTu1zlz9fP3sUAKDXyOlo4vh9TknK8M+BvwEAE0Yort00edYCOHVygaamDHdv38D+vX8hNiYapQxLo259K6z78y+UMiyd1Snp/3Xs1gcpycnYsXEVYmOiUOmH6pi99A+UzUMV1ffo/r17GDKov/z578sWAwCcf+yCBb8tESusIsGpfQd8jIjAhvVrER4ehhoWltiweStKc0oXEREREVGBkQg5ldeoWOfOnVG/fn3Mnz8/y+OBgYFo0KAB0tPTv+q8R++9V0Z436V65UqKHUKR9SH2+100+ltVL6svdghFFgcV8k9LxX/yaDj/nErPf3OOo0rPT0RERERFm6gVPpMnT0ZcXFy2x6tWrQofH58CjIiIiEg5iuqUZCIiIiIqHkQd8LGzy3nNFV1dXdjb2xdQNERERERERERExUOh3padiIioqGKBDxERERGJSU3sAIiIiIiIiIiISLlY4UNERKQCXMOHiIiIiMTECh8iIiIiIiIiomKGFT5EREQqwAIfIiIiIhITB3yIiIhUgFO6iIiIiEhMnNJFRERERERERFTMsMKHiIhIBVjgQ0RERERiYoUPEREREREREVExwwofIiIiFeAaPkREREQkJlb4EBEREREREREVM6zwISIiUgEW+BARERGRmFjhQ0REVMz5+/vD2dkZZmZmkEgkOHTokMJxNzc3SCQShYeTk5NCn4iICPTt2xclSpRAyZIlMXjwYMTGxhbgXRARERHR1+CADxERkQp8OYCi7MfXiIuLQ7169fDHH39k28fJyQlv3ryRP/bs2aNwvG/fvrh//z5Onz6NI0eOwN/fH0OHDs1XboiIiIhI9Tili4iISAUK05Su9u3bo3379jn2kclkKFu2bJbHgoKCcOLECVy7dg2NGjUCAKxbtw4dOnTAihUrYGZmpvSYiYiIiOjbsMKHiIioCEpKSkJ0dLTCIykpKd/n8/X1RZkyZVCjRg0MHz4cHz58kB+7dOkSSpYsKR/sAYDWrVtDTU0NV65c+ab7ICIiIiLV4IAPERGRCqh6StfixYthYGCg8Fi8eHG+YnVycsLOnTtx9uxZLF26FH5+fmjfvj3S0tIAAG/fvkWZMmUUXqOurg5DQ0O8ffv2m3NFRERERMrHKV1ERERF0PTp0zFhwgSFNplM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V6h4cf1+d7569eplnwTIzc3VmTNnFB8fr06dOmngwIHFbinv7e0t6eo38bfccouCg4PL5g06ga1bt6pr166SpO7du2vLli32c+Hh4crJyZEknT9/XqGhofL19VXNmjUlXa2bEQ04V1RSHZOSkuTj46MuXbpo8ODBunTpUpHP/fjjj3XvvfeWaV5nVVIdf5ORkSGr1aratWtLko4cOSKLxaKwsLAyzerMSqrj4cOH1axZM0lS8+bNlZKSosqVKys4OFj5+fn23+v4/7y8vFSlShX7xwcPHlSjRo3k7e2ttm3b6rvvvpMk3XbbbZKu3s3S4oLff/GnOQAAAMrMiRMn7M2F65k/f742bdqkxx57TPPmzdOxY8dUqVIlJScna+PGjfL19dXMmTM1btw4bdiwQZGRkVqxYkWx68ycOVP169dX1apVValSJaPektM5f/68AgICJF1tqJ07d85+rn79+tq/f7+aNGmit956S/fff7/9XF5enqZNm6axY8eWeWZnVFIdT506pTNnzmjt2rWKjo4ushzxwoULysjI4LbT/09JdfzN8uXL1a9fP/vH//znP/X444+XWUZXUFIdGzdurA0bNkiS1q1bp/Pnz8vLy0tNmzZVgwYN1K1btyJLvVDc7+srqdgPERITE13yz0YaPgAAGMBiMfYBuKqaNWvq+PHj1z1fUFCgCRMmqH379po+fbpOnDihevXqqU2bNho0aJAmT56sgoIC7d+/X1OnTlVsbKyWL1+ujIyMYteaOHGiDh06pJMnT2r79u1Gvi2nEhQUpOzsbElX96n4/XTT4sWLFRMTo3379hVZtiBJDz/8sB555BHVr1+/zDM7o5LqGBQUpI4dO8pisahz587at2+f/dyqVavUu3fvMs/rrEqq428++eQT+9Kaw4cPS5Lq1KlTZhldQUl1fOihh5Senq64uDj5+/urevXqOnDggHbu3KlDhw5p586d+sc//mFWdJfw+/pKkqenp/3XCxYs0JUrVzRo0CAzot0UGj4AAAAoMz179tSqVat08uRJSVc3G92zZ4/9fFpami5cuKCUlBRNnDhRNptNVqtVY8eO1fvvv6/MzExt2bJFERERmj59upKTk7Vjxw6NHDmyyOtYrVZJV79p9/PzK1cTPm3atNG6deskSWvWrCmyD4rNZrMv7QgNDVVWVpYk6ZlnntFtt92m/v37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\n",
      "text/plain": [
       "<Figure size 1400x600 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Primera prueba para ver el entrenamiento\n",
    "# He probado antes en local para ver como alcanzaba un 100% de acc y 0.001 de loss con pocos datos\n",
    "train_model(model, trainer, train_dataset, val_dataset, epochs=20, device=device, save_model = \"experimento1.2\", name=\"!pretrain\", wdb=True, local=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4849da29",
   "metadata": {
    "papermill": {
     "duration": 0.971056,
     "end_time": "2025-03-05T10:49:52.517529",
     "exception": false,
     "start_time": "2025-03-05T10:49:51.546473",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 6786867,
     "sourceId": 10917159,
     "sourceType": "datasetVersion"
    },
    {
     "isSourceIdPinned": true,
     "modelId": 257789,
     "modelInstanceId": 236101,
     "sourceId": 275713,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 30919,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 9865.574319,
   "end_time": "2025-03-05T10:49:56.142138",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-03-05T08:05:30.567819",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
