{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "a0302fcd",
   "metadata": {
    "papermill": {
     "duration": 0.003781,
     "end_time": "2025-03-05T07:27:44.414813",
     "exception": false,
     "start_time": "2025-03-05T07:27:44.411032",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "faa2d496",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:27:44.422278Z",
     "iopub.status.busy": "2025-03-05T07:27:44.421999Z",
     "iopub.status.idle": "2025-03-05T07:27:52.384372Z",
     "shell.execute_reply": "2025-03-05T07:27:52.383685Z"
    },
    "papermill": {
     "duration": 7.96766,
     "end_time": "2025-03-05T07:27:52.385871",
     "exception": false,
     "start_time": "2025-03-05T07:27:44.418211",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import torch\n",
    "from PIL import Image\n",
    "from torchvision import transforms\n",
    "\n",
    "class HistogramEqualization:\n",
    "    \"\"\"Aplica ecualización de histograma para ajuste de contraste\"\"\"\n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar ecualización de histograma por canal\n",
    "        if len(img_np.shape) == 3:  # Imagen RGB\n",
    "            img_eq = np.zeros_like(img_np)\n",
    "            for i in range(3):\n",
    "                img_eq[:,:,i] = cv2.equalizeHist(img_np[:,:,i])\n",
    "        else:  # Imagen en escala de grises\n",
    "            img_eq = cv2.equalizeHist(img_np)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_eq)\n",
    "\n",
    "class BilateralFilter:\n",
    "    \"\"\"Aplica filtrado bilateral para suavizado preservando bordes\"\"\"\n",
    "    def __init__(self, d=9, sigma_color=75, sigma_space=75):\n",
    "        self.d = d  # Diámetro de cada vecindario de píxeles\n",
    "        self.sigma_color = sigma_color  # Filtro sigma en el espacio de color\n",
    "        self.sigma_space = sigma_space  # Filtro sigma en el espacio de coordenadas\n",
    "    \n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar filtro bilateral\n",
    "        img_filtered = cv2.bilateralFilter(\n",
    "            img_np, self.d, self.sigma_color, self.sigma_space)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_filtered)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "b387c9a6",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:27:52.393477Z",
     "iopub.status.busy": "2025-03-05T07:27:52.393166Z",
     "iopub.status.idle": "2025-03-05T07:27:52.403533Z",
     "shell.execute_reply": "2025-03-05T07:27:52.402656Z"
    },
    "papermill": {
     "duration": 0.015598,
     "end_time": "2025-03-05T07:27:52.404870",
     "exception": false,
     "start_time": "2025-03-05T07:27:52.389272",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "class DatasetExperiment1(Dataset):\n",
    "    def __init__(self, mode='train', batch_size=32, local = False, path = ''):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            mode (str): 'train', 'val' o 'test'.\n",
    "            transform: Transformaciones de torchvision a aplicar a las imágenes.\n",
    "        \"\"\"\n",
    "        assert mode in ['train', 'val', 'test'], \"Mode must be 'train', 'val', or 'test'\"\n",
    "        if local:\n",
    "            print(\"LOCAL MODE ENABLED\")\n",
    "\n",
    "        # Transformaciones del paper\n",
    "        # Histogram equalization for contrast adjustment\n",
    "        # and bilateral filtering for smoothness\n",
    "        self.transform =  transforms.Compose([\n",
    "            transforms.Resize((224, 224)),\n",
    "            HistogramEqualization(),\n",
    "            BilateralFilter(d=9, sigma_color=75, sigma_space=75),\n",
    "            transforms.ToTensor(),\n",
    "        ])\n",
    "        self.data_path = os.path.join(path, mode)\n",
    "        self.classes = sorted(os.listdir(self.data_path))  # Lista de clases\n",
    "        self.data = []\n",
    "        self.batch_size = batch_size\n",
    "        # Cargar imágenes con sus etiquetas\n",
    "        \n",
    "\n",
    "        for label, class_name in enumerate(self.classes):\n",
    "            class_path = os.path.join(self.data_path, class_name)\n",
    "            i = 0\n",
    "            for img_name in os.listdir(class_path):\n",
    "                if local and i >= 3:\n",
    "                    break\n",
    "                img_path = os.path.join(class_path, img_name)\n",
    "                self.data.append((img_path, label))\n",
    "                i += 1\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        img_path, label = self.data[idx]\n",
    "        image = Image.open(img_path).convert('RGB')\n",
    "\n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "        \n",
    "        return image, label\n",
    "    \n",
    "    def get_dataloader(self, shuffle=True):       \n",
    "        return DataLoader(self, batch_size=self.batch_size, shuffle=shuffle)\n",
    "    def show_image(self, idx, transformed=True, figsize=(10, 8)):\n",
    "        \"\"\"\n",
    "        Muestra una imagen del dataset con su etiqueta\n",
    "        \n",
    "        Args:\n",
    "            idx (int): Índice de la imagen a mostrar\n",
    "            transformed (bool): Si es True, muestra la imagen transformada. \n",
    "                               Si es False, muestra la imagen original.\n",
    "            figsize (tuple): Tamaño de la figura (ancho, alto)\n",
    "        \"\"\"\n",
    "        if idx >= len(self):\n",
    "            print(f\"Índice {idx} fuera de rango. El dataset tiene {len(self)} elementos.\")\n",
    "            return\n",
    "        \n",
    "        img_path, label = self.data[idx]\n",
    "        class_name = self.classes[label]\n",
    "        \n",
    "        plt.figure(figsize=figsize)\n",
    "        \n",
    "        # Mostrar imagen original\n",
    "        orig_img = Image.open(img_path).convert('RGB')\n",
    "        plt.subplot(1, 2, 1)\n",
    "        plt.imshow(orig_img)\n",
    "        plt.title(f\"Original: Clase {class_name} (label {label})\")\n",
    "        plt.axis('off')\n",
    "        \n",
    "        # Mostrar imagen transformada si se solicita\n",
    "        if transformed:\n",
    "            trans_img = self.transform(orig_img)\n",
    "            # Convertir tensor a numpy para visualización\n",
    "            if isinstance(trans_img, torch.Tensor):\n",
    "                trans_img = trans_img.permute(1, 2, 0).numpy()  # Cambiar de CxHxW a HxWxC\n",
    "                # Normalizar valores para visualización\n",
    "                trans_img = np.clip(trans_img, 0, 1)\n",
    "            \n",
    "            plt.subplot(1, 2, 2)\n",
    "            plt.imshow(trans_img)\n",
    "            plt.title(\"Con transformaciones aplicadas\")\n",
    "            plt.axis('off')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Imprimir información adicional\n",
    "        print(f\"Ruta de la imagen: {img_path}\")\n",
    "        print(f\"Clase: {class_name} (label {label})\")\n",
    "        print(f\"Resolución original: {orig_img.size}\")\n",
    "        if transformed and isinstance(trans_img, np.ndarray):\n",
    "            print(f\"Resolución después de transformaciones: {trans_img.shape[:2]}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d98a4698",
   "metadata": {
    "papermill": {
     "duration": 0.003004,
     "end_time": "2025-03-05T07:27:52.411248",
     "exception": false,
     "start_time": "2025-03-05T07:27:52.408244",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train config 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "45903cdc",
   "metadata": {
    "papermill": {
     "duration": 0.002798,
     "end_time": "2025-03-05T07:27:52.417126",
     "exception": false,
     "start_time": "2025-03-05T07:27:52.414328",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The hyperparameters of the proposed ensemble model were\n",
    "tuned by the trial-and-error method. \n",
    "L2 regularization, \n",
    "batch normalization, \n",
    "dropout rate\n",
    "\n",
    "The Adam optimizer\n",
    "Epochs = 150. \n",
    "The learning rate scheduler and ReduceLROnPlateau were used for handling\n",
    "the learning rate with an initial value of 0.001. The loss\n",
    "function used for the model was categorical cross-entropy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b696de13",
   "metadata": {
    "papermill": {
     "duration": 0.002919,
     "end_time": "2025-03-05T07:27:52.423119",
     "exception": false,
     "start_time": "2025-03-05T07:27:52.420200",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Trainer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "14b5a26a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:27:52.430551Z",
     "iopub.status.busy": "2025-03-05T07:27:52.430281Z",
     "iopub.status.idle": "2025-03-05T07:28:00.935026Z",
     "shell.execute_reply": "2025-03-05T07:28:00.934266Z"
    },
    "papermill": {
     "duration": 8.510262,
     "end_time": "2025-03-05T07:28:00.936554",
     "exception": false,
     "start_time": "2025-03-05T07:27:52.426292",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install -q lightning\n",
    "import lightning.pytorch as pl\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torchmetrics as tm\n",
    "from torchmetrics.classification import MulticlassConfusionMatrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "class Classification(pl.LightningModule):\n",
    "    \"\"\"\n",
    "    Trainer para entrenar un modelo de clasificación multiclase\n",
    "    y de dimension 1 con valores [0, num_classes]\n",
    "    \"\"\"\n",
    "    def __init__(self, model, device, L1=0.001, L2=0.001, lr=0.001, patience=5, factor=0.1, betas=(0.9, 0.999)):\n",
    "        super().__init__()\n",
    "        self.save_hyperparameters(ignore=(\"model\",))\n",
    "\n",
    "        self.model = model\n",
    "\n",
    "        self.loss_fn = nn.CrossEntropyLoss()\n",
    "        self.L1 = L1\n",
    "        self.L2 = L2\n",
    "        self.learning_rate = lr\n",
    "        self.patience = patience\n",
    "        self.factor = factor\n",
    "        self.betas = betas\n",
    "\n",
    "        self.num_classes = 5\n",
    "        self.confusion_matrix = MulticlassConfusionMatrix(num_classes=5).to(device)\n",
    "        self.auc_metric = tm.AUROC(num_classes=5, task=\"multiclass\").to(device)  # Definir métrica AUROC para clasificación multiclase\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.model(x)\n",
    "\n",
    "    def training_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        \n",
    "        # Regularización L1\n",
    "        L1_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L1_reg = L1_reg + torch.sum(torch.abs(param))\n",
    "        \n",
    "        # Regularización L2\n",
    "        L2_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L2_reg = L2_reg + torch.sum(param ** 2)\n",
    "        \n",
    "        # Añadir regularización a la pérdida\n",
    "        prediction_loss = loss\n",
    "        loss = loss + self.L1 * L1_reg + self.L2 * L2_reg\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        loss.backward()\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "\n",
    "        return {\"loss\": prediction_loss, \"real_loss\": loss, \"ACC\": ACC, \"recall\": recall, \"precision\": precision, \"f1_score\": f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def validation_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular métricas\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "        return {\"loss\": loss, \"ACC\": ACC, \"precision\" : precision, \"recall\": recall, \"f1_score\" : f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def transform_classes(self, y):\n",
    "        # Convertir las clases a un formato de one-hot encoding\n",
    "        return torch.nn.functional.one_hot(y.to(torch.int64), num_classes=5).to(float).squeeze()\n",
    "    def restart_epoch(self, plot = False):\n",
    "        if plot:\n",
    "            self.plot()\n",
    "        self.confusion_matrix.reset()\n",
    "        self.auc_metric.reset()\n",
    "    def calculate_metrics_from_confusion_matrix(self):\n",
    "        # Obtener la matriz de confusión (suponiendo que es un tensor de torch)\n",
    "        cm = self.confusion_matrix.compute()\n",
    "        total_samples = cm.sum()\n",
    "        \n",
    "        # Verdaderos positivos por clase (diagonal de la matriz)\n",
    "        true_positives = torch.diag(cm)\n",
    "        \n",
    "        # Predicciones totales por clase (sumar columnas)\n",
    "        predicted_positives = cm.sum(dim=0)\n",
    "        \n",
    "        # Ejemplos reales por clase (sumar filas)\n",
    "        actual_positives = cm.sum(dim=1)\n",
    "        \n",
    "        # Calcular falsos positivos y falsos negativos por clase\n",
    "        false_positives = predicted_positives - true_positives\n",
    "        false_negatives = actual_positives - true_positives\n",
    "        \n",
    "        # Calcular verdaderos negativos por clase\n",
    "        true_negatives = total_samples - (actual_positives + predicted_positives - true_positives)\n",
    "        \n",
    "        # Calcular métricas por clase con robustez para evitar división por cero\n",
    "        precision_per_class = true_positives / (predicted_positives + 1e-8)\n",
    "        recall_per_class = true_positives / (actual_positives + 1e-8)\n",
    "        specificity_per_class = true_negatives / (true_negatives + false_positives + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Promediar las métricas por clase\n",
    "        precision = precision_per_class.mean()\n",
    "        recall = recall_per_class.mean()\n",
    "        specificity = specificity_per_class.mean()\n",
    "        f1 = f1_per_class.mean()\n",
    "        \n",
    "        # Calcular Accuracy (exactitud)\n",
    "        ACC = true_positives.sum() / total_samples\n",
    "        \n",
    "        # Calcular el AUC (suponiendo que self.auc_metric ya está correctamente definido)\n",
    "        AUC = self.auc_metric.compute()\n",
    "        \n",
    "        return precision, recall, f1, ACC, AUC, specificity\n",
    "\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        optimizer = torch.optim.Adam(self.model.parameters(),\n",
    "                                     lr=self.learning_rate,\n",
    "                                     betas=self.betas)\n",
    "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer,\n",
    "                                                               factor=self.factor,\n",
    "                                                               patience=self.patience)\n",
    "        return optimizer, scheduler\n",
    "    def plot(self, epoch=0):\n",
    "        # Computa la matriz de confusión y las métricas por clase\n",
    "        cm = self.confusion_matrix.compute().cpu().numpy()\n",
    "        support = cm.sum(axis=1)\n",
    "        precision_per_class = np.diag(cm) / (cm.sum(axis=0) + 1e-8)\n",
    "        recall_per_class = np.diag(cm) / (cm.sum(axis=1) + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Cálculo de especificidad por clase\n",
    "        FP = cm.sum(axis=0) - np.diag(cm)\n",
    "        FN = cm.sum(axis=1) - np.diag(cm)\n",
    "        TN = cm.sum() - (FP + FN + np.diag(cm))\n",
    "        specificity_per_class = TN / (TN + FP + 1e-8)\n",
    "        \n",
    "        accuracy = np.diag(cm).sum() / cm.sum()\n",
    "\n",
    "        # Crea dos subplots: uno para la matriz de confusión y otro para la tabla de métricas\n",
    "        fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "        # Subplot 1: Matriz de confusión con heatmap\n",
    "        sns.heatmap(cm, annot=True, fmt=\"d\", ax=axs[0], cmap=\"Blues\")\n",
    "        axs[0].set_title(\"Matriz de Confusión epoch \" + str(epoch))\n",
    "        axs[0].set_xlabel(\"Predicción\")\n",
    "        axs[0].set_ylabel(\"Real\")\n",
    "\n",
    "        # Subplot 2: Tabla de métricas por clase\n",
    "        table_data = []\n",
    "        for i in range(self.num_classes):\n",
    "            table_data.append([f\"Clase {i}\",\n",
    "                            f\"{precision_per_class[i]:.2f}\",\n",
    "                            f\"{recall_per_class[i]:.2f}\",\n",
    "                            f\"{f1_per_class[i]:.2f}\",\n",
    "                            f\"{specificity_per_class[i]:.2f}\",\n",
    "                            int(support[i])])\n",
    "        axs[1].axis('tight')\n",
    "        axs[1].axis('off')\n",
    "        table = axs[1].table(cellText=table_data,\n",
    "                            colLabels=[\"Clase\", \"Precision\", \"Sensivity/Recall\", \"F1\", \"Specificity\", \"Support\"],\n",
    "                            cellLoc=\"center\", loc=\"center\")\n",
    "        axs[1].set_title(f\"Metrics por clase\\nAccuracy General: {accuracy:.2f}\", pad=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "140baa59",
   "metadata": {
    "papermill": {
     "duration": 0.003085,
     "end_time": "2025-03-05T07:28:00.943002",
     "exception": false,
     "start_time": "2025-03-05T07:28:00.939917",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "4b18fc0d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:28:00.950276Z",
     "iopub.status.busy": "2025-03-05T07:28:00.949917Z",
     "iopub.status.idle": "2025-03-05T07:28:00.956403Z",
     "shell.execute_reply": "2025-03-05T07:28:00.955780Z"
    },
    "papermill": {
     "duration": 0.011355,
     "end_time": "2025-03-05T07:28:00.957575",
     "exception": false,
     "start_time": "2025-03-05T07:28:00.946220",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.nn import functional as F\n",
    "import torchvision.models as models\n",
    "\n",
    "class ResNet50Model(nn.Module):\n",
    "    \"\"\"\n",
    "    Modelo basado en ResNet50 para la clasificación de radiografías.\n",
    "    Permite personalización en el número de clases y si se usa transfer learning.\n",
    "    \"\"\"\n",
    "    def __init__(self, num_classes=5, pretrained=True, freeze_backbone=False, dropout_rate=0.3):\n",
    "        \"\"\"\n",
    "        Inicializa el modelo ResNet50.\n",
    "        \n",
    "        Args:\n",
    "            num_classes (int): Número de clases para la clasificación (default: 5)\n",
    "            pretrained (bool): Si se deben usar pesos preentrenados en ImageNet (default: True)\n",
    "            freeze_backbone (bool): Si se deben congelar las capas de la red base (default: False)\n",
    "            dropout_rate (float): Tasa de dropout aplicada antes de la capa de clasificación (default: 0.3)\n",
    "        \"\"\"\n",
    "        super(ResNet50Model, self).__init__()\n",
    "        \n",
    "        # Cargar el modelo base ResNet50\n",
    "        self.model = models.resnet50(weights='IMAGENET1K_V2' if pretrained else None)\n",
    "        \n",
    "        # Nombre del modelo para identificación\n",
    "        self.name = \"ResNet50\"\n",
    "        \n",
    "        # Congelar los parámetros de la red si se especifica\n",
    "        if freeze_backbone:\n",
    "            for param in self.model.parameters():\n",
    "                param.requires_grad = False\n",
    "        \n",
    "        # Reemplazar la capa de clasificación final\n",
    "        in_features = self.model.fc.in_features\n",
    "        self.model.fc = nn.Sequential(\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(in_features, 512),\n",
    "            nn.ReLU(),\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(512, num_classes)\n",
    "        )\n",
    "    \n",
    "    def forward(self, x):\n",
    "        \"\"\"\n",
    "        Propagación hacia adelante a través del modelo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor con las predicciones de clase [batch_size, num_classes]\n",
    "        \"\"\"\n",
    "        return self.model(x)\n",
    "    \n",
    "    def get_features(self, x):\n",
    "        \"\"\"\n",
    "        Obtiene los features del modelo antes de la capa de clasificación.\n",
    "        Útil para análisis de características o transferencia de estilo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor de características [batch_size, 2048]\n",
    "        \"\"\"\n",
    "        # Extrae todas las capas excepto la final\n",
    "        modules = list(self.model.children())[:-1]\n",
    "        feature_extractor = nn.Sequential(*modules)\n",
    "        \n",
    "        # Obtiene los features y los aplana\n",
    "        features = feature_extractor(x)\n",
    "        features = features.view(features.size(0), -1)\n",
    "        \n",
    "        return features\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "113aa2ec",
   "metadata": {
    "papermill": {
     "duration": 0.002868,
     "end_time": "2025-03-05T07:28:00.963465",
     "exception": false,
     "start_time": "2025-03-05T07:28:00.960597",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "8cc58db1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:28:00.970505Z",
     "iopub.status.busy": "2025-03-05T07:28:00.970285Z",
     "iopub.status.idle": "2025-03-05T07:28:02.781485Z",
     "shell.execute_reply": "2025-03-05T07:28:02.780742Z"
    },
    "papermill": {
     "duration": 1.816467,
     "end_time": "2025-03-05T07:28:02.783032",
     "exception": false,
     "start_time": "2025-03-05T07:28:00.966565",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "from tqdm import tqdm\n",
    "from wandb import wandb\n",
    "\n",
    "def create_tqdm_bar(iterable, desc, mode):\n",
    "    return tqdm(enumerate(iterable),total=len(iterable), ncols=200, desc=desc)\n",
    "\n",
    "def train_model(model, trainer, train_dataset, val_dataset, epochs=5, transform=None, device='cuda', save_model = \"\", name=\"Test\", wdb=True, local=False, project=\"oai-knee-cartilage-segmentation\"):\n",
    "    if wdb:\n",
    "        if wandb.run is not None:\n",
    "            wandb.finish()\n",
    "        wandb.init(\n",
    "            project=project,\n",
    "            name=name,\n",
    "            # track hyperparameters and run metadata\n",
    "            config={\n",
    "                \"model\": model.name,\n",
    "                \"Batch_size\": train_dataset.batch_size,\n",
    "                \"learning_rate\": trainer.learning_rate,\n",
    "                \"L1\": trainer.L1,\n",
    "                \"L2\": trainer.L2,\n",
    "                \"patience\": trainer.patience,\n",
    "                \"factor\": trainer.factor,\n",
    "                \"betas\": trainer.betas,\n",
    "                \"epochs\": epochs,\n",
    "            }\n",
    "        )\n",
    "    train_loader = train_dataset.get_dataloader(shuffle=True)\n",
    "    val_loader = val_dataset.get_dataloader(shuffle=True)\n",
    "    model.to(device)\n",
    "    train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = local, save_model = save_model)\n",
    "    \n",
    "\n",
    "def train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = False, save_model = \"\"):\n",
    "    \"\"\"\n",
    "    train the given model\n",
    "    \"\"\"\n",
    "    optimizer, scheduler = trainer.configure_optimizers()\n",
    "    best_model = None\n",
    "    best_loss = float('inf')\n",
    "    for epoch in range(epochs):        \n",
    "        training_loss = []\n",
    "        validation_loss = []\n",
    "\n",
    "        training_loss_num = 0\n",
    "        complete_loss_num = 0\n",
    "        validation_loss_num = 0\n",
    "\n",
    "        # use training data\n",
    "        model.train()\n",
    "\n",
    "        training_loop = create_tqdm_bar(train_loader, desc=f'Training Epoch [{epoch + 1}/{epochs}]', mode='train')\n",
    "        for train_iteration, batch in training_loop:\n",
    "            batch = batch[0].to(device), batch[1].to(device)\n",
    "            optimizer.zero_grad()\n",
    "            res = trainer.training_step(batch[0], batch[1])\n",
    "            optimizer.step()\n",
    "\n",
    "            training_loss.append(res['loss'].item())\n",
    "            training_loss_num += res['loss'].item()\n",
    "            complete_loss_num += res['real_loss'].item()\n",
    "            # Update the progress bar.\n",
    "            training_loop.set_postfix(train_loss=\"{:.4f}\".format(training_loss_num / (train_iteration + 1)),\n",
    "                                      complete_loss=\"{:.4f}\".format(complete_loss_num / (train_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      sensivity=res['recall'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "            if wdb:\n",
    "                \n",
    "                wandb.log({\"train_loss\": training_loss_num / (train_iteration + 1),\n",
    "                           \"complete_loss\": complete_loss_num / (train_iteration + 1),\n",
    "                        \"train_acc\": res['ACC'],\n",
    "                        \"train_recall\": res['recall'].item(),\n",
    "                        \"train_precision\": res['precision'].item(),\n",
    "                        \"train_specifity\": res['specificity'].item(),\n",
    "                        \"train_f1_score\": res['f1_score'].item(),\n",
    "                        \"train_AUC\": res['AUC'],\n",
    "                        \"epoch\": epoch,\n",
    "                        \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        trainer.restart_epoch(plot=False)\n",
    "        # use validation data\n",
    "        if local:\n",
    "            continue\n",
    "        model.eval()\n",
    "        val_loop = create_tqdm_bar(val_loader, desc=f'Validation Epoch [{epoch + 1}/{epochs}]', mode='val')\n",
    "        with torch.no_grad():\n",
    "            for val_iteration, batch in val_loop:\n",
    "                batch = batch[0].to(device), batch[1].to(device)\n",
    "                res = trainer.validation_step(batch[0], batch[1])  \n",
    "                validation_loss.append(res['loss'].item())\n",
    "                validation_loss_num += res['loss'].item()\n",
    "                val_loop.set_postfix(val_loss = \"{:.8f}\".format(validation_loss_num / (val_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "                                      \n",
    "        if wdb:\n",
    "            wandb.log({\"val_loss\": validation_loss_num / (val_iteration + 1),\n",
    "                    \"val_acc\": res['ACC'],\n",
    "                    \"val_recall\": res['recall'].item(),\n",
    "                    \"val_precision\": res['precision'].item(),\n",
    "                    \"val_specificity\": res['specificity'].item(),\n",
    "                    \"val_f1_score\": res['f1_score'].item(),\n",
    "                    \"val_AUC\": res['AUC'],\n",
    "                    \"epoch\": epoch,\n",
    "                    \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        if validation_loss_num < best_loss:\n",
    "            best_loss = validation_loss_num\n",
    "            if save_model != \"\":\n",
    "                torch.save(model.state_dict(), f\"best_model_{model.__class__.__name__}_{save_model}_epoch_{epoch}.pt\")\n",
    "        scheduler.step(res['loss'].item())\n",
    "        trainer.restart_epoch(plot=False)\n",
    "    \n",
    "    test_model(model, val_loader, trainer, device, wdb)\n",
    "\n",
    "def test_model(model, test_loader, trainer, device, wdb=False):\n",
    "    \"\"\"\n",
    "    Test the given model\n",
    "    \"\"\"\n",
    "    model.eval()\n",
    "    model.to(device)\n",
    "\n",
    "    epoch_loss = 0.0\n",
    "    avg_loss = 0.0\n",
    "    trainer.restart_epoch(plot = False)\n",
    "    for batch in test_loader:\n",
    "        inputs, labels = batch\n",
    "        inputs = inputs.to(device)\n",
    "        \n",
    "        labels = labels.to(device)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            res = trainer.validation_step(inputs, labels)\n",
    "            # Extraer valores escalares\n",
    "            loss = res['loss']\n",
    "            \n",
    "        loss_value = loss.item()\n",
    "        # Calcular promedios\n",
    "        epoch_loss += loss_value\n",
    "\n",
    "    ACC_value = res['ACC']\n",
    "    recall_value = res['recall'].item()\n",
    "    precision_value = res['precision'].item()\n",
    "    f1_score_value = res['f1_score'].item()\n",
    "    AUC_value = res['AUC']\n",
    "    avg_loss = epoch_loss / len(test_loader)\n",
    "    if wdb:\n",
    "        wandb.log({\"test_loss\": avg_loss, \"test_acc\": ACC_value.item(),\n",
    "                \"test_recall\": recall_value, \"test_precision\": precision_value,\n",
    "                \"test_f1_score\": f1_score_value, \"test_AUC\" : AUC_value})\n",
    "    \n",
    "    print(f\"Test model {model.__class__.__name__} - Loss: {avg_loss:.2f}, ACC: {ACC_value:.2f}, AUC: {AUC_value:.2f}, Sensivility: {recall_value:.2f}, Specificity: {precision_value:.2f}\")\n",
    "\n",
    "    trainer.restart_epoch(plot = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "53d2573c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:28:02.790251Z",
     "iopub.status.busy": "2025-03-05T07:28:02.790032Z",
     "iopub.status.idle": "2025-03-05T07:28:05.885195Z",
     "shell.execute_reply": "2025-03-05T07:28:05.884497Z"
    },
    "papermill": {
     "duration": 3.100463,
     "end_time": "2025-03-05T07:28:05.886817",
     "exception": false,
     "start_time": "2025-03-05T07:28:02.786354",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Downloading: \"https://download.pytorch.org/models/resnet50-11ad3fa6.pth\" to /root/.cache/torch/hub/checkpoints/resnet50-11ad3fa6.pth\n",
      "100%|██████████| 97.8M/97.8M [00:00<00:00, 230MB/s]\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "BATCH_SIZE = 64\n",
    "LEARNING_RATE = 0.0005\n",
    "FACTOR = 0.1\n",
    "L1 = 0.00\n",
    "L2 = 0.0005\n",
    "PATIENCE = 5\n",
    "BETAS=(0.9, 0.999)\n",
    "DATASET_PATH = '/kaggle/input/aug-oai-capitulo3/augmented_oai'\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "train_dataset = DatasetExperiment1('train', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "val_dataset = DatasetExperiment1('val', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "model_state = torch.load('/kaggle/input/model1_epoch31/pytorch/default/1/best_model_ResNet50Model_experimento1.2_epoch_31.pt', map_location = device, weights_only=True)\n",
    "model = ResNet50Model(num_classes=len(train_dataset.classes), dropout_rate=0.5)\n",
    "model.load_state_dict(model_state)\n",
    "trainer = Classification(model, device, L1=L1, L2=L2, lr=LEARNING_RATE, patience=PATIENCE, factor=FACTOR, betas=BETAS)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "3ac3a2d5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:28:05.895172Z",
     "iopub.status.busy": "2025-03-05T07:28:05.894938Z",
     "iopub.status.idle": "2025-03-05T07:28:06.889650Z",
     "shell.execute_reply": "2025-03-05T07:28:06.888816Z"
    },
    "papermill": {
     "duration": 1.000318,
     "end_time": "2025-03-05T07:28:06.891194",
     "exception": false,
     "start_time": "2025-03-05T07:28:05.890876",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Using wandb-core as the SDK backend.  Please refer to https://wandb.me/wandb-core for more information.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33mchermar\u001b[0m (\u001b[33mchermar-universitat-polit-cnica-de-val-ncia\u001b[0m). Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m If you're specifying your api key in code, ensure this code is not shared publicly.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m Consider setting the WANDB_API_KEY environment variable, or running `wandb login` from the command line.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Appending key for api.wandb.ai to your netrc file: /root/.netrc\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wandb.login(key=\"254f72e7bdeec44797ba1b2a91ebbc63900b89f4\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "ddc3cac1",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-05T07:28:06.900122Z",
     "iopub.status.busy": "2025-03-05T07:28:06.899846Z",
     "iopub.status.idle": "2025-03-05T10:15:29.806552Z",
     "shell.execute_reply": "2025-03-05T10:15:29.805664Z"
    },
    "papermill": {
     "duration": 10042.912574,
     "end_time": "2025-03-05T10:15:29.808024",
     "exception": false,
     "start_time": "2025-03-05T07:28:06.895450",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Tracking run with wandb version 0.19.1\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run data is saved locally in \u001b[35m\u001b[1m/kaggle/working/wandb/run-20250305_072806-0uxbsfbl\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run \u001b[1m`wandb offline`\u001b[0m to turn off syncing.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Syncing run \u001b[33mre_train_experimento1.4\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: ⭐️ View project at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: 🚀 View run at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation/runs/0uxbsfbl\u001b[0m\n",
      "Training Epoch [1/20]: 100%|███████████████████████████████████████| 459/459 [12:32<00:00,  1.64s/it, AUC=0.831, acc=0.588, complete_loss=2.2141, sensivity=0.477, specificity=0.878, train_loss=0.9748]\n",
      "Validation Epoch [1/20]: 100%|█████████████████████████████████████████████████████████████████████████████| 13/13 [00:16<00:00,  1.25s/it, AUC=0.76, acc=0.474, specificity=0.833, val_loss=1.33707650]\n",
      "Training Epoch [2/20]: 100%|███████████████████████████████████████| 459/459 [07:58<00:00,  1.04s/it, AUC=0.832, acc=0.591, complete_loss=2.0979, sensivity=0.477, specificity=0.878, train_loss=0.9674]\n",
      "Validation Epoch [2/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.801, acc=0.537, specificity=0.855, val_loss=1.12653683]\n",
      "Training Epoch [3/20]: 100%|███████████████████████████████████████| 459/459 [07:54<00:00,  1.03s/it, AUC=0.835, acc=0.594, complete_loss=2.0087, sensivity=0.488, specificity=0.879, train_loss=0.9619]\n",
      "Validation Epoch [3/20]: 100%|█████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.796, acc=0.51, specificity=0.844, val_loss=1.29490975]\n",
      "Training Epoch [4/20]: 100%|████████████████████████████████████████| 459/459 [07:57<00:00,  1.04s/it, AUC=0.838, acc=0.596, complete_loss=1.9272, sensivity=0.483, specificity=0.88, train_loss=0.9516]\n",
      "Validation Epoch [4/20]:   0%|                                                                                                                                                   | 0/13 [00:00<?, ?it/s]/usr/local/lib/python3.10/dist-packages/torchmetrics/utilities/prints.py:43: UserWarning: No positive samples in targets, true positive value should be meaningless. Returning zero tensor in true positive score\n",
      "  warnings.warn(*args, **kwargs)  # noqa: B028\n",
      "Validation Epoch [4/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.32it/s, AUC=0.805, acc=0.549, specificity=0.872, val_loss=1.10004049]\n",
      "Training Epoch [5/20]: 100%|█████████████████████████████████████████| 459/459 [07:56<00:00,  1.04s/it, AUC=0.841, acc=0.6, complete_loss=1.8553, sensivity=0.495, specificity=0.881, train_loss=0.9419]\n",
      "Validation Epoch [5/20]: 100%|██████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.8, acc=0.532, specificity=0.861, val_loss=1.10951421]\n",
      "Training Epoch [6/20]: 100%|███████████████████████████████████████| 459/459 [07:51<00:00,  1.03s/it, AUC=0.845, acc=0.606, complete_loss=1.7885, sensivity=0.515, specificity=0.883, train_loss=0.9299]\n",
      "Validation Epoch [6/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.40it/s, AUC=0.807, acc=0.531, specificity=0.854, val_loss=1.17724231]\n",
      "Training Epoch [7/20]: 100%|████████████████████████████████████████| 459/459 [07:59<00:00,  1.04s/it, AUC=0.85, acc=0.616, complete_loss=1.7249, sensivity=0.547, specificity=0.886, train_loss=0.9149]\n",
      "Validation Epoch [7/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.34it/s, AUC=0.797, acc=0.533, specificity=0.852, val_loss=1.22551916]\n",
      "Training Epoch [8/20]: 100%|███████████████████████████████████████| 459/459 [07:54<00:00,  1.03s/it, AUC=0.853, acc=0.618, complete_loss=1.6725, sensivity=0.555, specificity=0.886, train_loss=0.9065]\n",
      "Validation Epoch [8/20]: 100%|██████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.81, acc=0.51, specificity=0.867, val_loss=1.18502367]\n",
      "Training Epoch [9/20]: 100%|███████████████████████████████████████| 459/459 [07:59<00:00,  1.05s/it, AUC=0.856, acc=0.625, complete_loss=1.6196, sensivity=0.571, specificity=0.888, train_loss=0.8934]\n",
      "Validation Epoch [9/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.811, acc=0.492, specificity=0.859, val_loss=1.16892376]\n",
      "Training Epoch [10/20]: 100%|██████████████████████████████████████| 459/459 [07:57<00:00,  1.04s/it, AUC=0.877, acc=0.656, complete_loss=1.5299, sensivity=0.611, specificity=0.897, train_loss=0.8244]\n",
      "Validation Epoch [10/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.39it/s, AUC=0.855, acc=0.636, specificity=0.89, val_loss=0.88202802]\n",
      "Training Epoch [11/20]: 100%|███████████████████████████████████████| 459/459 [08:00<00:00,  1.05s/it, AUC=0.886, acc=0.67, complete_loss=1.4915, sensivity=0.629, specificity=0.902, train_loss=0.7897]\n",
      "Validation Epoch [11/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.34it/s, AUC=0.857, acc=0.628, specificity=0.889, val_loss=0.88485963]\n",
      "Training Epoch [12/20]: 100%|██████████████████████████████████████| 459/459 [08:00<00:00,  1.05s/it, AUC=0.889, acc=0.677, complete_loss=1.4743, sensivity=0.638, specificity=0.904, train_loss=0.7763]\n",
      "Validation Epoch [12/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.853, acc=0.621, specificity=0.887, val_loss=0.91986636]\n",
      "Training Epoch [13/20]: 100%|███████████████████████████████████████| 459/459 [08:01<00:00,  1.05s/it, AUC=0.893, acc=0.686, complete_loss=1.4529, sensivity=0.65, specificity=0.907, train_loss=0.7586]\n",
      "Validation Epoch [13/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.858, acc=0.624, specificity=0.889, val_loss=0.89847099]\n",
      "Training Epoch [14/20]: 100%|██████████████████████████████████████| 459/459 [08:00<00:00,  1.05s/it, AUC=0.896, acc=0.691, complete_loss=1.4402, sensivity=0.658, specificity=0.908, train_loss=0.7496]\n",
      "Validation Epoch [14/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.38it/s, AUC=0.852, acc=0.626, specificity=0.887, val_loss=0.95563912]\n",
      "Training Epoch [15/20]: 100%|██████████████████████████████████████| 459/459 [07:59<00:00,  1.04s/it, AUC=0.898, acc=0.692, complete_loss=1.4284, sensivity=0.661, specificity=0.909, train_loss=0.7414]\n",
      "Validation Epoch [15/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.853, acc=0.621, specificity=0.889, val_loss=0.92842303]\n",
      "Training Epoch [16/20]: 100%|███████████████████████████████████████| 459/459 [07:59<00:00,  1.04s/it, AUC=0.901, acc=0.696, complete_loss=1.4140, sensivity=0.665, specificity=0.91, train_loss=0.7305]\n",
      "Validation Epoch [16/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.31it/s, AUC=0.851, acc=0.629, specificity=0.89, val_loss=0.92204834]\n",
      "Training Epoch [17/20]: 100%|██████████████████████████████████████| 459/459 [07:56<00:00,  1.04s/it, AUC=0.907, acc=0.707, complete_loss=1.3881, sensivity=0.675, specificity=0.914, train_loss=0.7065]\n",
      "Validation Epoch [17/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.37it/s, AUC=0.852, acc=0.621, specificity=0.888, val_loss=0.93033716]\n",
      "Training Epoch [18/20]: 100%|███████████████████████████████████████| 459/459 [07:55<00:00,  1.04s/it, AUC=0.907, acc=0.708, complete_loss=1.3840, sensivity=0.68, specificity=0.914, train_loss=0.7027]\n",
      "Validation Epoch [18/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.37it/s, AUC=0.853, acc=0.628, specificity=0.89, val_loss=0.92158348]\n",
      "Training Epoch [19/20]: 100%|██████████████████████████████████████| 459/459 [07:58<00:00,  1.04s/it, AUC=0.907, acc=0.708, complete_loss=1.3837, sensivity=0.675, specificity=0.914, train_loss=0.7027]\n",
      "Validation Epoch [19/20]: 100%|████████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.31it/s, AUC=0.853, acc=0.624, specificity=0.89, val_loss=0.93195424]\n",
      "Training Epoch [20/20]: 100%|██████████████████████████████████████| 459/459 [07:58<00:00,  1.04s/it, AUC=0.908, acc=0.711, complete_loss=1.3789, sensivity=0.681, specificity=0.915, train_loss=0.6982]\n",
      "Validation Epoch [20/20]: 100%|███████████████████████████████████████████████████████████████████████████| 13/13 [00:09<00:00,  1.35it/s, AUC=0.853, acc=0.629, specificity=0.891, val_loss=0.95353237]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test model ResNet50Model - Loss: 0.94, ACC: 0.63, AUC: 0.85, Sensivility: 0.60, Specificity: 0.63\n"
     ]
    },
    {
     "data": {
      "image/png": "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OXMGo0ePRrdu3VC1alWkp6fjzz//hFQqRZcuXT57DysrK/z00094/vw5qlatir/++gu3bt3C5s2boaGhAQAYOnQoNm3aBE9PT1y/fh0VKlTA3r17cfHiRaxevRr6+vpf9FyZKleujFmzZmHRokVwdnZG586dIZPJ8O+//8LKygpLly7N9rx27dph//796NSpE9q2bYtnz55h48aNqF69OuLj4xX9Bg8ejMjISLi7u6Ns2bIICQnBr7/+irp16yrWH5oyZQr+/vtvtGvXDp6enrC3t0dCQgLu3LmDvXv34vnz5zA1Nc3X8xEVJxzwISIiIiKib9rGjRthb2+PTZs2YebMmVBXV0eFChXQp08fODk5KfrNnTsXISEhWL58OeLi4uDq6vrFAz4AMGjQIJibm2PZsmVYtGgRNDQ0YGtriwkTJgAA6tSpg5YtW+Lw4cN4/fo1dHR0UKdOHRw7dgyNGjX67PWNjY2xfft2jBkzBr///jtKly6NdevWYciQIYo+2tra8Pf3x/Tp07F9+3bExsaiWrVq8PLygqen5xc/08cWLlyIihUr4tdff8WsWbOgo6OD2rVro2/fvjme4+npibCwMGzatAknTpxA9erV4e3tDV9fX/j7+yv69enTB5s3b8b69esRHR0NCwsL9OjRA/Pnz1dMTdPR0UFAQACWLFkCX19f7NixAwYGBqhatSoWLFiQp4WviUoCiZBbXR0REREREREVG25uboiIiMDdu3fFDoWIRMY1fIiIiIiIiIiIShgO+BARERERERERlTAc8CEiIiIiIiIiKmG4hg8RERERERERUQnDCh8iIiIiIiIiohKGAz5ERERERERERCUMB3yIiIiIiIioyNi2bRskEgmeP38udihExRoHfIiIiIiISOXWr18PiUSChg0bih1KsfTu3TtMnz4dtWrVgp6eHrS0tFC5cmUMGDAAFy5cEDu8Iic4OBitWrWCnp4eTExM0LdvX4SHh+f5/Li4OEydOhUVK1aETCZDmTJl0LVrVyQmJir6nDt3Dh06dIC1tTW0tLRgYWGBVq1a4eLFi6p4JKIvpi52AEREREREVPL5+PigQoUKuHr1Kp48eYLKlSuLHVKxcfXqVbRt2xZxcXHo2bMnhg8fDplMhmfPnuHgwYPYtm0bAgIC4OLiInaoRcKrV6/g4uICQ0NDLFmyBPHx8Vi5ciXu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yPNnOHpkHGKio2BoaAS7GjWxYeufqGRTRaSIiwdNTRnu37mJw/t2IiEuFobGpVCjdj0s+9ULRsYmYodX5Pj+tQsAMGRAP6X2BYuXoENHDlp8TqvWbRAVGYn169YiIiIc1WztsH7TFpT65qZ0cdFmIiIiIhKPRBAEQewg0tLSEBHxYeFiU1PTr941SPu70QUR1jfp9YU1YodQbIXFJIsdQrFVwUxH7BCKLTUOKuSblor/5KHdYYNKr5/09wiVXp+IiIiIijfRKnw+pqGhAUtLS7HDICIiKjhcw4eIiIiIRMSfRomIiIiIiIiISpgiUeFDRERU4nC6HRERERGJiBU+REREREREREQlDCt8iIiIVIFr+BARERGRiDjgQ0REpAqc0kVEREREIuKfH4mIiIiIiIiIShhW+BAREamAhBU+RERERCQiVvgQEREREREREZUwrPAhIiJSAVb4EBEREZGYWOFDRERERERERFTCsMKHiIhIFVjgQ0REREQiYoUPEREREREREVEJwwofIiIiFeAaPkREREQkJg74EBERqQAHfIiIiIhITJzSRURERERERERUwrDCh4iISAVY4UNEREREYmKFDxERERERERFRCcMKHyIiIhVghQ8RERERiYkVPkREREREREREJQwrfIiIiFSBBT5EREREJCJW+BARERERERERlTCs8CEiIlIBruFDRERERGJihQ8RERERERERUQnDCh8iIiIVYIUPEREREYmJAz5EREQqwAEfIiIiIhITp3QREREREREREZUwrPAhIiJSAVb4EBEREZGYWOFDRERERERERFTCsMKHiIhIFVjgQ0REREQiYoUPEREREREREVEJwwofIiIiFeAaPkREREQkJlb4EBERERERERGVMKzwISIiUgFW+BARERGRmDjgQ0REpAIc8CEiIiIiMXFKFxERERERERFRCcMBHyIiIlWQqPiVR0uXLkWDBg2gr68Pc3NzdOzYEQ8fPlTqk5ycjFGjRqFUqVLQ09NDly5d8PbtW6U+L168QNu2baGjowNzc3NMmTIF6enpX5QSIiIiIio8HPAhIiIqwQICAjBq1ChcvnwZfn5+SEtLQ4sWLZCQkKDoM2HCBBw+fBi+vr4ICAhAaGgoOnfurDgul8vRtm1bpKamIjAwENu3b8e2bdswd+5cMR6JiIiIiPJAIgiCIHYQBU37u9Fi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7a/oc//aRfiuX6b4fOfqBQCAZt080bz7gEKPuagIvn8Po4Z4Kj5f8/NPAIA27Tti7sIlOB9wFovnzVIcnzN9EgBg0LCRGDJ8dKHGWhydOXYIpczMUad+I7FDKdJ8/9oFABgyoJ9S+4LFS9ChIwctPqdV6zaIiozE+nVrERERjmq2dli/aQtKcUoXEREREVGhkQi5ldeoWIcOHVC3bl0sXLgw2+NBQUH47rvvkJHxZVOhDt4OK4jwvkmulb/dKpmv9SoySewQii2b0rpih1BsqXFUId+0VPwnj3oLz6j0+jfmuqv0+kRERERUvIla4TNlyhQkJCTkeLxy5co4e/ZsIUZERERUMIrjlGQiIiIiKjlEHfBxdnbO9biuri5cXV0LKRoiIiIiIiIiopKhSG/LTkREVFyxwIeIiIiIxKQmdgBERERERERERFSwWOFDRESkAlzDh4iIiIjExAofIiIiIiIiIqIShhU+REREKsACHyIiIiISEwd8iIiIVIBTuoiIiIhITJzSRURERERERERUwrDCh4iISAVY4ENEREREYmKFDxERERERERFRCcMKHyIiIhXgGj5EREREJCZW+BARERERERERlTCs8CEiIlIBFvgQERERkZhY4UNEREREREREVMKwwoeIiEgFuIYPEREREYmJAz5EREQqwPEeIiIiIhITp3QREREREREREZUwrPAhIiJSAU7pIiIiIiIxscKHiIiIiIiIiKiEYYUPERGRCrDCh4iIiIjExAofIiIiIiIiIqIShhU+REREKsACHyIiIiISEyt8iIiIiIiIiIhKGFb4EBERqQDX8CEiIiIiMXHAh4iISAU43kNEREREYuKULiIiIiIiIiKiEoYVPkRERCrAKV1EREREJCZW+BARERERERERlTCs8CEiIlIBFvgQERERkZhY4UNEREREREREVMKwwoeIiEgF1FjiQ0REREQiYoUPEREREREREVEJwwofIiIiFWCBDxERERGJiQM+REREKsBt2YmIiIhITJzSRURERERERERUwrDCh4iISAXUWOBDxcyLFy8QEREhdhjFXkpKCmQymdhhFHvMY8FhLgsG81gwmMeCYWpqinLlyn22Hwd8iIiISrhz585hxYoVuH79Ot68eYMDBw6gY8eOiuOenp7Yvn270jktW7bE8ePHFZ9HRkZizJgxOHz4MNTU1NClSxes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KjH33DOT13Mf83jIfU/uvOdah+k11+dzU0fHoI6OkZaWpt69e9tXXt2MwZ9vAgBQMnGXLrijWrVqcavcO/DLEgXqeGeoo+NQS8egjo5BHZ2PtQAAAAAAAAAehgkfAAAMwIAPAAAAzMSEDwAABvCyGPsA3Nn27dsVGxurli1bqnXr1tq7d68WLVqk2bNnO+xnfPDBB4qJiVGTJk00fvx4h13XXYwdO1YxMTHq06ePcnNz7ccTEhIUGxur2NhYRUREaObMmZKkt956S82aNVO7du109uxZs2K7nNutoySdOHFCfn5++vbbb82I7JJut46nTp3S448/rlatWik+Pt6s2C7nt+p45coVe71Gjx4t6fqdnH6pbZ06ddS1a1ezYrukzMxMPfzwwwoMDLT/WV2xYoWaNm2qNm3a6NSpU5KkgQMHqmnTpmrSpIk2btxoZuRioeEDAAAAp7l48aIGDRqkjz76SElJSUpISJCXl+Pfkvbu3Vtbt27Vzp07tWPHDvub95Jg//79On36tLZu3aqoqCitXLnSfq5r165KTExUYmKiqlevri5duig9PV1r167V119/rddee02vvfaaieldx+3W8RfTp09Xs2bNTEjsmopTx9GjR2vu3LnasmWLJk2aZFJy13KzOr777rvq3LmztmzZoqysLO3evVvVqlWz17Zbt26Ffo9CKlOmjNauXasnnnhCkpSXl6e3335biYmJmjx5sv3vwbFjx2r79u1at26dXn75ZTMjFwsNHwAADOBlsRj6ANzV2rVr1aVLF1WuXFmSFBQUVGTzzqefflotW7ZU8+bNdfLkSeXm5qpTp072T6uzs7OVkZGhLl26qHXr1urVq1eRW8r7+vpKuv4m/q677lJISIhzXqAL2L59u9q2bStJat++vbZt21bkOenp6bJarapSpYpOnDih2rVry2KxqH79+tq6dauzI7uk262jdH2qwmKxKCIiwqlZXdnt1jE3N1fHjx/XyJEj1bp1a23fvt3ZkV3Szep47Ngx1atXT5JUv359JScnF/rezz//nIbP//Dx8VHFihXtXx85ckS1atWSr6+vmjVrpgMHDkiS7r33XknX72ZpccP3XzR8AAAA4DRnzpxReHj4TZ+zYMECJSUlaeTIkZo/f75OnjypMmXKKDExUVu2bJG/v7+mTZumYcOGafPmzapTp44SEhKKXGfa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\n",
      "text/plain": [
       "<Figure size 1400x600 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Primera prueba para ver el entrenamiento\n",
    "# He probado antes en local para ver como alcanzaba un 100% de acc y 0.001 de loss con pocos datos\n",
    "train_model(model, trainer, train_dataset, val_dataset, epochs=20, device=device, save_model = \"experimento1.2\", name=\"re_train_experimento1.4\", wdb=True, local=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "95d096ef",
   "metadata": {
    "papermill": {
     "duration": 0.890652,
     "end_time": "2025-03-05T10:15:31.713942",
     "exception": false,
     "start_time": "2025-03-05T10:15:30.823290",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 6786867,
     "sourceId": 10917159,
     "sourceType": "datasetVersion"
    },
    {
     "isSourceIdPinned": true,
     "modelId": 257789,
     "modelInstanceId": 236101,
     "sourceId": 275713,
     "sourceType": "modelInstanceVersion"
    }
   ],
   "dockerImageVersionId": 30919,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 10073.528008,
   "end_time": "2025-03-05T10:15:35.415910",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-03-05T07:27:41.887902",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
