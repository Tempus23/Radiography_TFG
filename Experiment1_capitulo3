{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4cd8faaf",
   "metadata": {
    "papermill": {
     "duration": 0.00393,
     "end_time": "2025-03-04T16:50:30.169799",
     "exception": false,
     "start_time": "2025-03-04T16:50:30.165869",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "bd329478",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:30.177355Z",
     "iopub.status.busy": "2025-03-04T16:50:30.177092Z",
     "iopub.status.idle": "2025-03-04T16:50:37.497263Z",
     "shell.execute_reply": "2025-03-04T16:50:37.496566Z"
    },
    "papermill": {
     "duration": 7.325631,
     "end_time": "2025-03-04T16:50:37.498900",
     "exception": false,
     "start_time": "2025-03-04T16:50:30.173269",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import torch\n",
    "from PIL import Image\n",
    "from torchvision import transforms\n",
    "\n",
    "class HistogramEqualization:\n",
    "    \"\"\"Aplica ecualizaci贸n de histograma para ajuste de contraste\"\"\"\n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar ecualizaci贸n de histograma por canal\n",
    "        if len(img_np.shape) == 3:  # Imagen RGB\n",
    "            img_eq = np.zeros_like(img_np)\n",
    "            for i in range(3):\n",
    "                img_eq[:,:,i] = cv2.equalizeHist(img_np[:,:,i])\n",
    "        else:  # Imagen en escala de grises\n",
    "            img_eq = cv2.equalizeHist(img_np)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_eq)\n",
    "\n",
    "class BilateralFilter:\n",
    "    \"\"\"Aplica filtrado bilateral para suavizado preservando bordes\"\"\"\n",
    "    def __init__(self, d=9, sigma_color=75, sigma_space=75):\n",
    "        self.d = d  # Di谩metro de cada vecindario de p铆xeles\n",
    "        self.sigma_color = sigma_color  # Filtro sigma en el espacio de color\n",
    "        self.sigma_space = sigma_space  # Filtro sigma en el espacio de coordenadas\n",
    "    \n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar filtro bilateral\n",
    "        img_filtered = cv2.bilateralFilter(\n",
    "            img_np, self.d, self.sigma_color, self.sigma_space)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_filtered)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "c82e601c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:37.506402Z",
     "iopub.status.busy": "2025-03-04T16:50:37.506067Z",
     "iopub.status.idle": "2025-03-04T16:50:37.516599Z",
     "shell.execute_reply": "2025-03-04T16:50:37.515936Z"
    },
    "papermill": {
     "duration": 0.015586,
     "end_time": "2025-03-04T16:50:37.517887",
     "exception": false,
     "start_time": "2025-03-04T16:50:37.502301",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "class DatasetExperiment1(Dataset):\n",
    "    def __init__(self, mode='train', batch_size=32, local = False, path = ''):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            mode (str): 'train', 'val' o 'test'.\n",
    "            transform: Transformaciones de torchvision a aplicar a las im谩genes.\n",
    "        \"\"\"\n",
    "        assert mode in ['train', 'val', 'test'], \"Mode must be 'train', 'val', or 'test'\"\n",
    "        if local:\n",
    "            print(\"LOCAL MODE ENABLED\")\n",
    "\n",
    "        # Transformaciones del paper\n",
    "        # Histogram equalization for contrast adjustment\n",
    "        # and bilateral filtering for smoothness\n",
    "        self.transform =  transforms.Compose([\n",
    "            transforms.Resize((224, 224)),\n",
    "            HistogramEqualization(),\n",
    "            BilateralFilter(d=9, sigma_color=75, sigma_space=75),\n",
    "            transforms.ToTensor(),\n",
    "        ])\n",
    "        self.data_path = os.path.join(path, mode)\n",
    "        self.classes = sorted(os.listdir(self.data_path))  # Lista de clases\n",
    "        self.data = []\n",
    "        self.batch_size = batch_size\n",
    "        # Cargar im谩genes con sus etiquetas\n",
    "        \n",
    "\n",
    "        for label, class_name in enumerate(self.classes):\n",
    "            class_path = os.path.join(self.data_path, class_name)\n",
    "            i = 0\n",
    "            for img_name in os.listdir(class_path):\n",
    "                if local and i >= 3:\n",
    "                    break\n",
    "                img_path = os.path.join(class_path, img_name)\n",
    "                self.data.append((img_path, label))\n",
    "                i += 1\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        img_path, label = self.data[idx]\n",
    "        image = Image.open(img_path).convert('RGB')\n",
    "\n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "        \n",
    "        return image, label\n",
    "    \n",
    "    def get_dataloader(self, shuffle=True):       \n",
    "        return DataLoader(self, batch_size=self.batch_size, shuffle=shuffle)\n",
    "    def show_image(self, idx, transformed=True, figsize=(10, 8)):\n",
    "        \"\"\"\n",
    "        Muestra una imagen del dataset con su etiqueta\n",
    "        \n",
    "        Args:\n",
    "            idx (int): ndice de la imagen a mostrar\n",
    "            transformed (bool): Si es True, muestra la imagen transformada. \n",
    "                               Si es False, muestra la imagen original.\n",
    "            figsize (tuple): Tama帽o de la figura (ancho, alto)\n",
    "        \"\"\"\n",
    "        if idx >= len(self):\n",
    "            print(f\"ndice {idx} fuera de rango. El dataset tiene {len(self)} elementos.\")\n",
    "            return\n",
    "        \n",
    "        img_path, label = self.data[idx]\n",
    "        class_name = self.classes[label]\n",
    "        \n",
    "        plt.figure(figsize=figsize)\n",
    "        \n",
    "        # Mostrar imagen original\n",
    "        orig_img = Image.open(img_path).convert('RGB')\n",
    "        plt.subplot(1, 2, 1)\n",
    "        plt.imshow(orig_img)\n",
    "        plt.title(f\"Original: Clase {class_name} (label {label})\")\n",
    "        plt.axis('off')\n",
    "        \n",
    "        # Mostrar imagen transformada si se solicita\n",
    "        if transformed:\n",
    "            trans_img = self.transform(orig_img)\n",
    "            # Convertir tensor a numpy para visualizaci贸n\n",
    "            if isinstance(trans_img, torch.Tensor):\n",
    "                trans_img = trans_img.permute(1, 2, 0).numpy()  # Cambiar de CxHxW a HxWxC\n",
    "                # Normalizar valores para visualizaci贸n\n",
    "                trans_img = np.clip(trans_img, 0, 1)\n",
    "            \n",
    "            plt.subplot(1, 2, 2)\n",
    "            plt.imshow(trans_img)\n",
    "            plt.title(\"Con transformaciones aplicadas\")\n",
    "            plt.axis('off')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Imprimir informaci贸n adicional\n",
    "        print(f\"Ruta de la imagen: {img_path}\")\n",
    "        print(f\"Clase: {class_name} (label {label})\")\n",
    "        print(f\"Resoluci贸n original: {orig_img.size}\")\n",
    "        if transformed and isinstance(trans_img, np.ndarray):\n",
    "            print(f\"Resoluci贸n despu茅s de transformaciones: {trans_img.shape[:2]}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85b772b7",
   "metadata": {
    "papermill": {
     "duration": 0.00285,
     "end_time": "2025-03-04T16:50:37.523895",
     "exception": false,
     "start_time": "2025-03-04T16:50:37.521045",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train config 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "380e995f",
   "metadata": {
    "papermill": {
     "duration": 0.002706,
     "end_time": "2025-03-04T16:50:37.529596",
     "exception": false,
     "start_time": "2025-03-04T16:50:37.526890",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The hyperparameters of the proposed ensemble model were\n",
    "tuned by the trial-and-error method. \n",
    "L2 regularization, \n",
    "batch normalization, \n",
    "dropout rate\n",
    "\n",
    "The Adam optimizer\n",
    "Epochs = 150. \n",
    "The learning rate scheduler and ReduceLROnPlateau were used for handling\n",
    "the learning rate with an initial value of 0.001. The loss\n",
    "function used for the model was categorical cross-entropy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "69b896d3",
   "metadata": {
    "papermill": {
     "duration": 0.002725,
     "end_time": "2025-03-04T16:50:37.535251",
     "exception": false,
     "start_time": "2025-03-04T16:50:37.532526",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Trainer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "e0b20b8c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:37.542004Z",
     "iopub.status.busy": "2025-03-04T16:50:37.541778Z",
     "iopub.status.idle": "2025-03-04T16:50:46.043634Z",
     "shell.execute_reply": "2025-03-04T16:50:46.042673Z"
    },
    "papermill": {
     "duration": 8.507111,
     "end_time": "2025-03-04T16:50:46.045220",
     "exception": false,
     "start_time": "2025-03-04T16:50:37.538109",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install -q lightning\n",
    "import lightning.pytorch as pl\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torchmetrics as tm\n",
    "from torchmetrics.classification import MulticlassConfusionMatrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "class Classification(pl.LightningModule):\n",
    "    \"\"\"\n",
    "    Trainer para entrenar un modelo de clasificaci贸n multiclase\n",
    "    y de dimension 1 con valores [0, num_classes]\n",
    "    \"\"\"\n",
    "    def __init__(self, model, device, L1=0.001, L2=0.001, lr=0.001, patience=5, factor=0.1, betas=(0.9, 0.999)):\n",
    "        super().__init__()\n",
    "        self.save_hyperparameters(ignore=(\"model\",))\n",
    "\n",
    "        self.model = model\n",
    "\n",
    "        self.loss_fn = nn.CrossEntropyLoss()\n",
    "        self.L1 = L1\n",
    "        self.L2 = L2\n",
    "        self.learning_rate = lr\n",
    "        self.patience = patience\n",
    "        self.factor = factor\n",
    "        self.betas = betas\n",
    "\n",
    "        self.num_classes = 5\n",
    "        self.confusion_matrix = MulticlassConfusionMatrix(num_classes=5).to(device)\n",
    "        self.auc_metric = tm.AUROC(num_classes=5, task=\"multiclass\").to(device)  # Definir m茅trica AUROC para clasificaci贸n multiclase\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.model(x)\n",
    "\n",
    "    def training_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        \n",
    "        # Regularizaci贸n L1\n",
    "        L1_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L1_reg = L1_reg + torch.sum(torch.abs(param))\n",
    "        \n",
    "        # Regularizaci贸n L2\n",
    "        L2_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L2_reg = L2_reg + torch.sum(param ** 2)\n",
    "        \n",
    "        # A帽adir regularizaci贸n a la p茅rdida\n",
    "        prediction_loss = loss\n",
    "        loss = loss + self.L1 * L1_reg + self.L2 * L2_reg\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular m茅tricas\n",
    "        loss.backward()\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "\n",
    "        return {\"loss\": prediction_loss, \"real_loss\": loss, \"ACC\": ACC, \"recall\": recall, \"precision\": precision, \"f1_score\": f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def validation_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular m茅tricas\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "        return {\"loss\": loss, \"ACC\": ACC, \"precision\" : precision, \"recall\": recall, \"f1_score\" : f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def transform_classes(self, y):\n",
    "        # Convertir las clases a un formato de one-hot encoding\n",
    "        return torch.nn.functional.one_hot(y.to(torch.int64), num_classes=5).to(float).squeeze()\n",
    "    def restart_epoch(self, plot = False):\n",
    "        if plot:\n",
    "            self.plot()\n",
    "        self.confusion_matrix.reset()\n",
    "        self.auc_metric.reset()\n",
    "    def calculate_metrics_from_confusion_matrix(self):\n",
    "        # Obtener la matriz de confusi贸n (suponiendo que es un tensor de torch)\n",
    "        cm = self.confusion_matrix.compute()\n",
    "        total_samples = cm.sum()\n",
    "        \n",
    "        # Verdaderos positivos por clase (diagonal de la matriz)\n",
    "        true_positives = torch.diag(cm)\n",
    "        \n",
    "        # Predicciones totales por clase (sumar columnas)\n",
    "        predicted_positives = cm.sum(dim=0)\n",
    "        \n",
    "        # Ejemplos reales por clase (sumar filas)\n",
    "        actual_positives = cm.sum(dim=1)\n",
    "        \n",
    "        # Calcular falsos positivos y falsos negativos por clase\n",
    "        false_positives = predicted_positives - true_positives\n",
    "        false_negatives = actual_positives - true_positives\n",
    "        \n",
    "        # Calcular verdaderos negativos por clase\n",
    "        true_negatives = total_samples - (actual_positives + predicted_positives - true_positives)\n",
    "        \n",
    "        # Calcular m茅tricas por clase con robustez para evitar divisi贸n por cero\n",
    "        precision_per_class = true_positives / (predicted_positives + 1e-8)\n",
    "        recall_per_class = true_positives / (actual_positives + 1e-8)\n",
    "        specificity_per_class = true_negatives / (true_negatives + false_positives + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Promediar las m茅tricas por clase\n",
    "        precision = precision_per_class.mean()\n",
    "        recall = recall_per_class.mean()\n",
    "        specificity = specificity_per_class.mean()\n",
    "        f1 = f1_per_class.mean()\n",
    "        \n",
    "        # Calcular Accuracy (exactitud)\n",
    "        ACC = true_positives.sum() / total_samples\n",
    "        \n",
    "        # Calcular el AUC (suponiendo que self.auc_metric ya est谩 correctamente definido)\n",
    "        AUC = self.auc_metric.compute()\n",
    "        \n",
    "        return precision, recall, f1, ACC, AUC, specificity\n",
    "\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        optimizer = torch.optim.Adam(self.model.parameters(),\n",
    "                                     lr=self.learning_rate,\n",
    "                                     betas=self.betas)\n",
    "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer,\n",
    "                                                               factor=self.factor,\n",
    "                                                               patience=self.patience)\n",
    "        return optimizer, scheduler\n",
    "    def plot(self, epoch=0):\n",
    "        # Computa la matriz de confusi贸n y las m茅tricas por clase\n",
    "        cm = self.confusion_matrix.compute().cpu().numpy()\n",
    "        support = cm.sum(axis=1)\n",
    "        precision_per_class = np.diag(cm) / (cm.sum(axis=0) + 1e-8)\n",
    "        recall_per_class = np.diag(cm) / (cm.sum(axis=1) + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # C谩lculo de especificidad por clase\n",
    "        FP = cm.sum(axis=0) - np.diag(cm)\n",
    "        FN = cm.sum(axis=1) - np.diag(cm)\n",
    "        TN = cm.sum() - (FP + FN + np.diag(cm))\n",
    "        specificity_per_class = TN / (TN + FP + 1e-8)\n",
    "        \n",
    "        accuracy = np.diag(cm).sum() / cm.sum()\n",
    "\n",
    "        # Crea dos subplots: uno para la matriz de confusi贸n y otro para la tabla de m茅tricas\n",
    "        fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "        # Subplot 1: Matriz de confusi贸n con heatmap\n",
    "        sns.heatmap(cm, annot=True, fmt=\"d\", ax=axs[0], cmap=\"Blues\")\n",
    "        axs[0].set_title(\"Matriz de Confusi贸n epoch \" + str(epoch))\n",
    "        axs[0].set_xlabel(\"Predicci贸n\")\n",
    "        axs[0].set_ylabel(\"Real\")\n",
    "\n",
    "        # Subplot 2: Tabla de m茅tricas por clase\n",
    "        table_data = []\n",
    "        for i in range(self.num_classes):\n",
    "            table_data.append([f\"Clase {i}\",\n",
    "                            f\"{precision_per_class[i]:.2f}\",\n",
    "                            f\"{recall_per_class[i]:.2f}\",\n",
    "                            f\"{f1_per_class[i]:.2f}\",\n",
    "                            f\"{specificity_per_class[i]:.2f}\",\n",
    "                            int(support[i])])\n",
    "        axs[1].axis('tight')\n",
    "        axs[1].axis('off')\n",
    "        table = axs[1].table(cellText=table_data,\n",
    "                            colLabels=[\"Clase\", \"Precision\", \"Sensivity/Recall\", \"F1\", \"Specificity\", \"Support\"],\n",
    "                            cellLoc=\"center\", loc=\"center\")\n",
    "        axs[1].set_title(f\"Metrics por clase\\nAccuracy General: {accuracy:.2f}\", pad=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7471f7cd",
   "metadata": {
    "papermill": {
     "duration": 0.002967,
     "end_time": "2025-03-04T16:50:46.051627",
     "exception": false,
     "start_time": "2025-03-04T16:50:46.048660",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7eb391d5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:46.058747Z",
     "iopub.status.busy": "2025-03-04T16:50:46.058289Z",
     "iopub.status.idle": "2025-03-04T16:50:46.065304Z",
     "shell.execute_reply": "2025-03-04T16:50:46.064495Z"
    },
    "papermill": {
     "duration": 0.012057,
     "end_time": "2025-03-04T16:50:46.066718",
     "exception": false,
     "start_time": "2025-03-04T16:50:46.054661",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.nn import functional as F\n",
    "import torchvision.models as models\n",
    "\n",
    "class ResNet50Model(nn.Module):\n",
    "    \"\"\"\n",
    "    Modelo basado en ResNet50 para la clasificaci贸n de radiograf铆as.\n",
    "    Permite personalizaci贸n en el n煤mero de clases y si se usa transfer learning.\n",
    "    \"\"\"\n",
    "    def __init__(self, num_classes=5, pretrained=True, freeze_backbone=False, dropout_rate=0.3):\n",
    "        \"\"\"\n",
    "        Inicializa el modelo ResNet50.\n",
    "        \n",
    "        Args:\n",
    "            num_classes (int): N煤mero de clases para la clasificaci贸n (default: 5)\n",
    "            pretrained (bool): Si se deben usar pesos preentrenados en ImageNet (default: True)\n",
    "            freeze_backbone (bool): Si se deben congelar las capas de la red base (default: False)\n",
    "            dropout_rate (float): Tasa de dropout aplicada antes de la capa de clasificaci贸n (default: 0.3)\n",
    "        \"\"\"\n",
    "        super(ResNet50Model, self).__init__()\n",
    "        \n",
    "        # Cargar el modelo base ResNet50\n",
    "        self.model = models.resnet50(weights='IMAGENET1K_V2' if pretrained else None)\n",
    "        \n",
    "        # Nombre del modelo para identificaci贸n\n",
    "        self.name = \"ResNet50\"\n",
    "        \n",
    "        # Congelar los par谩metros de la red si se especifica\n",
    "        if freeze_backbone:\n",
    "            for param in self.model.parameters():\n",
    "                param.requires_grad = False\n",
    "        \n",
    "        # Reemplazar la capa de clasificaci贸n final\n",
    "        in_features = self.model.fc.in_features\n",
    "        self.model.fc = nn.Sequential(\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(in_features, 512),\n",
    "            nn.ReLU(),\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(512, num_classes)\n",
    "        )\n",
    "    \n",
    "    def forward(self, x):\n",
    "        \"\"\"\n",
    "        Propagaci贸n hacia adelante a trav茅s del modelo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor con las predicciones de clase [batch_size, num_classes]\n",
    "        \"\"\"\n",
    "        return self.model(x)\n",
    "    \n",
    "    def get_features(self, x):\n",
    "        \"\"\"\n",
    "        Obtiene los features del modelo antes de la capa de clasificaci贸n.\n",
    "        til para an谩lisis de caracter铆sticas o transferencia de estilo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor de caracter铆sticas [batch_size, 2048]\n",
    "        \"\"\"\n",
    "        # Extrae todas las capas excepto la final\n",
    "        modules = list(self.model.children())[:-1]\n",
    "        feature_extractor = nn.Sequential(*modules)\n",
    "        \n",
    "        # Obtiene los features y los aplana\n",
    "        features = feature_extractor(x)\n",
    "        features = features.view(features.size(0), -1)\n",
    "        \n",
    "        return features\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a22d0698",
   "metadata": {
    "papermill": {
     "duration": 0.002843,
     "end_time": "2025-03-04T16:50:46.072625",
     "exception": false,
     "start_time": "2025-03-04T16:50:46.069782",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7f1729d4",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:46.079532Z",
     "iopub.status.busy": "2025-03-04T16:50:46.079237Z",
     "iopub.status.idle": "2025-03-04T16:50:47.909319Z",
     "shell.execute_reply": "2025-03-04T16:50:47.908678Z"
    },
    "papermill": {
     "duration": 1.835309,
     "end_time": "2025-03-04T16:50:47.910932",
     "exception": false,
     "start_time": "2025-03-04T16:50:46.075623",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "from tqdm import tqdm\n",
    "from wandb import wandb\n",
    "\n",
    "def create_tqdm_bar(iterable, desc, mode):\n",
    "    return tqdm(enumerate(iterable),total=len(iterable), ncols=200, desc=desc)\n",
    "\n",
    "def train_model(model, trainer, train_dataset, val_dataset, epochs=5, transform=None, device='cuda', save_model = \"\", name=\"Test\", wdb=True, local=False, project=\"oai-knee-cartilage-segmentation\"):\n",
    "    if wdb:\n",
    "        if wandb.run is not None:\n",
    "            wandb.finish()\n",
    "        wandb.init(\n",
    "            project=project,\n",
    "            name=name,\n",
    "            # track hyperparameters and run metadata\n",
    "            config={\n",
    "                \"model\": model.name,\n",
    "                \"Batch_size\": train_dataset.batch_size,\n",
    "                \"learning_rate\": trainer.learning_rate,\n",
    "                \"L1\": trainer.L1,\n",
    "                \"L2\": trainer.L2,\n",
    "                \"patience\": trainer.patience,\n",
    "                \"factor\": trainer.factor,\n",
    "                \"betas\": trainer.betas,\n",
    "                \"epochs\": epochs,\n",
    "            }\n",
    "        )\n",
    "    train_loader = train_dataset.get_dataloader(shuffle=True)\n",
    "    val_loader = val_dataset.get_dataloader(shuffle=True)\n",
    "    model.to(device)\n",
    "    train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = local, save_model = save_model)\n",
    "    \n",
    "\n",
    "def train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = False, save_model = \"\"):\n",
    "    \"\"\"\n",
    "    train the given model\n",
    "    \"\"\"\n",
    "    optimizer, scheduler = trainer.configure_optimizers()\n",
    "    best_model = None\n",
    "    best_loss = float('inf')\n",
    "    for epoch in range(epochs):        \n",
    "        training_loss = []\n",
    "        validation_loss = []\n",
    "\n",
    "        training_loss_num = 0\n",
    "        complete_loss_num = 0\n",
    "        validation_loss_num = 0\n",
    "\n",
    "        # use training data\n",
    "        model.train()\n",
    "\n",
    "        training_loop = create_tqdm_bar(train_loader, desc=f'Training Epoch [{epoch + 1}/{epochs}]', mode='train')\n",
    "        for train_iteration, batch in training_loop:\n",
    "            batch = batch[0].to(device), batch[1].to(device)\n",
    "            optimizer.zero_grad()\n",
    "            res = trainer.training_step(batch[0], batch[1])\n",
    "            optimizer.step()\n",
    "\n",
    "            training_loss.append(res['loss'].item())\n",
    "            training_loss_num += res['loss'].item()\n",
    "            complete_loss_num += res['real_loss'].item()\n",
    "            # Update the progress bar.\n",
    "            training_loop.set_postfix(train_loss=\"{:.4f}\".format(training_loss_num / (train_iteration + 1)),\n",
    "                                      complete_loss=\"{:.4f}\".format(complete_loss_num / (train_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      sensivity=res['recall'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "            if wdb:\n",
    "                \n",
    "                wandb.log({\"train_loss\": training_loss_num / (train_iteration + 1),\n",
    "                        \"train_acc\": res['ACC'],\n",
    "                        \"train_recall\": res['recall'].item(),\n",
    "                        \"train_precision\": res['precision'].item(),\n",
    "                        \"train_specifity\": res['specificity'].item(),\n",
    "                        \"train_f1_score\": res['f1_score'].item(),\n",
    "                        \"train_AUC\": res['AUC'],\n",
    "                        \"epoch\": epoch,\n",
    "                        \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        trainer.restart_epoch(plot=False)\n",
    "        # use validation data\n",
    "        if local:\n",
    "            continue\n",
    "        model.eval()\n",
    "        val_loop = create_tqdm_bar(val_loader, desc=f'Validation Epoch [{epoch + 1}/{epochs}]', mode='val')\n",
    "        with torch.no_grad():\n",
    "            for val_iteration, batch in val_loop:\n",
    "                batch = batch[0].to(device), batch[1].to(device)\n",
    "                res = trainer.validation_step(batch[0], batch[1])  \n",
    "                validation_loss.append(res['loss'].item())\n",
    "                validation_loss_num += res['loss'].item()\n",
    "                val_loop.set_postfix(val_loss = \"{:.8f}\".format(validation_loss_num / (val_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "                                      \n",
    "        if wdb:\n",
    "            wandb.log({\"val_loss\": validation_loss_num / (val_iteration + 1),\n",
    "                    \"val_acc\": res['ACC'],\n",
    "                    \"val_recall\": res['recall'].item(),\n",
    "                    \"val_precision\": res['precision'].item(),\n",
    "                    \"val_specificity\": res['specificity'].item(),\n",
    "                    \"val_f1_score\": res['f1_score'].item(),\n",
    "                    \"val_AUC\": res['AUC'],\n",
    "                    \"epoch\": epoch,\n",
    "                    \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        if validation_loss_num < best_loss:\n",
    "            best_loss = validation_loss_num\n",
    "            if save_model != \"\":\n",
    "                torch.save(model.state_dict(), f\"best_model_{model.__class__.__name__}_{save_model}_epoch_{epoch}.pt\")\n",
    "        scheduler.step(res['loss'].item())\n",
    "        trainer.restart_epoch(plot=False)\n",
    "    \n",
    "    test_model(model, val_loader, trainer, device, wdb)\n",
    "\n",
    "def test_model(model, test_loader, trainer, device, wdb=False):\n",
    "    \"\"\"\n",
    "    Test the given model\n",
    "    \"\"\"\n",
    "    model.eval()\n",
    "    model.to(device)\n",
    "\n",
    "    epoch_loss = 0.0\n",
    "    avg_loss = 0.0\n",
    "    trainer.restart_epoch(plot = False)\n",
    "    for batch in test_loader:\n",
    "        inputs, labels = batch\n",
    "        inputs = inputs.to(device)\n",
    "        \n",
    "        labels = labels.to(device)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            res = trainer.validation_step(inputs, labels)\n",
    "            # Extraer valores escalares\n",
    "            loss = res['loss']\n",
    "            \n",
    "        loss_value = loss.item()\n",
    "        # Calcular promedios\n",
    "        epoch_loss += loss_value\n",
    "\n",
    "    ACC_value = res['ACC']\n",
    "    recall_value = res['recall'].item()\n",
    "    precision_value = res['precision'].item()\n",
    "    f1_score_value = res['f1_score'].item()\n",
    "    AUC_value = res['AUC']\n",
    "    avg_loss = epoch_loss / len(test_loader)\n",
    "    if wdb:\n",
    "        wandb.log({\"test_loss\": avg_loss, \"test_acc\": ACC_value.item(),\n",
    "                \"test_recall\": recall_value, \"test_precision\": precision_value,\n",
    "                \"test_f1_score\": f1_score_value, \"test_AUC\" : AUC_value})\n",
    "    \n",
    "    print(f\"Test model {model.__class__.__name__} - Loss: {avg_loss:.2f}, ACC: {ACC_value:.2f}, AUC: {AUC_value:.2f}, Sensivility: {recall_value:.2f}, Specificity: {precision_value:.2f}\")\n",
    "\n",
    "    trainer.restart_epoch(plot = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a9f56eb7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:47.918102Z",
     "iopub.status.busy": "2025-03-04T16:50:47.917887Z",
     "iopub.status.idle": "2025-03-04T16:50:49.638850Z",
     "shell.execute_reply": "2025-03-04T16:50:49.637868Z"
    },
    "papermill": {
     "duration": 1.726338,
     "end_time": "2025-03-04T16:50:49.640617",
     "exception": false,
     "start_time": "2025-03-04T16:50:47.914279",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Downloading: \"https://download.pytorch.org/models/resnet50-11ad3fa6.pth\" to /root/.cache/torch/hub/checkpoints/resnet50-11ad3fa6.pth\n",
      "100%|| 97.8M/97.8M [00:00<00:00, 217MB/s]\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "BATCH_SIZE = 64\n",
    "LEARNING_RATE = 0.001\n",
    "FACTOR = 0.1\n",
    "L1 = 0.00\n",
    "L2 = 0.001\n",
    "PATIENCE = 4\n",
    "BETAS=(0.9, 0.999)\n",
    "DATASET_PATH = '/kaggle/input/aug-oai-capitulo3/augmented_oai'\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "train_dataset = DatasetExperiment1('train', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "val_dataset = DatasetExperiment1('val', batch_size=BATCH_SIZE, local=False, path = DATASET_PATH)\n",
    "\n",
    "model = ResNet50Model(num_classes=len(train_dataset.classes), dropout_rate=0.3)\n",
    "trainer = Classification(model, device, L1=L1, L2=L2, lr=LEARNING_RATE, patience=PATIENCE, factor=FACTOR, betas=BETAS)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "1e641df7",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:49.649051Z",
     "iopub.status.busy": "2025-03-04T16:50:49.648810Z",
     "iopub.status.idle": "2025-03-04T16:50:50.357108Z",
     "shell.execute_reply": "2025-03-04T16:50:50.356380Z"
    },
    "papermill": {
     "duration": 0.713589,
     "end_time": "2025-03-04T16:50:50.358271",
     "exception": false,
     "start_time": "2025-03-04T16:50:49.644682",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Using wandb-core as the SDK backend.  Please refer to https://wandb.me/wandb-core for more information.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33mchermar\u001b[0m (\u001b[33mchermar-universitat-polit-cnica-de-val-ncia\u001b[0m). Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m If you're specifying your api key in code, ensure this code is not shared publicly.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m Consider setting the WANDB_API_KEY environment variable, or running `wandb login` from the command line.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Appending key for api.wandb.ai to your netrc file: /root/.netrc\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wandb.login(key=\"254f72e7bdeec44797ba1b2a91ebbc63900b89f4\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "cdde0668",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-04T16:50:50.366808Z",
     "iopub.status.busy": "2025-03-04T16:50:50.366555Z",
     "iopub.status.idle": "2025-03-04T19:38:07.958556Z",
     "shell.execute_reply": "2025-03-04T19:38:07.957642Z"
    },
    "papermill": {
     "duration": 10037.597945,
     "end_time": "2025-03-04T19:38:07.960195",
     "exception": false,
     "start_time": "2025-03-04T16:50:50.362250",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Tracking run with wandb version 0.19.1\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run data is saved locally in \u001b[35m\u001b[1m/kaggle/working/wandb/run-20250304_165050-s25k5zby\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run \u001b[1m`wandb offline`\u001b[0m to turn off syncing.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Syncing run \u001b[33mExperimento1.3\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: 猸锔 View project at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m:  View run at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation/runs/s25k5zby\u001b[0m\n",
      "Training Epoch [1/20]: 100%|| 459/459 [11:18<00:00,  1.48s/it, AUC=0.761, acc=0.509, complete_loss=194.9940, sensivity=0.398, specificity=0.852, train_loss=1.1522]\n",
      "Validation Epoch [1/20]: 100%|| 13/13 [00:14<00:00,  1.12s/it, AUC=0.744, acc=0.467, specificity=0.831, val_loss=1.28771160]\n",
      "Training Epoch [2/20]: 100%|| 459/459 [08:02<00:00,  1.05s/it, AUC=0.771, acc=0.527, complete_loss=132.3077, sensivity=0.397, specificity=0.856, train_loss=1.1203]\n",
      "Validation Epoch [2/20]: 100%|| 13/13 [00:09<00:00,  1.30it/s, AUC=0.754, acc=0.488, specificity=0.836, val_loss=1.15083459]\n",
      "Training Epoch [3/20]: 100%|| 459/459 [08:05<00:00,  1.06s/it, AUC=0.772, acc=0.525, complete_loss=91.0270, sensivity=0.411, specificity=0.857, train_loss=1.1167]\n",
      "Validation Epoch [3/20]: 100%|| 13/13 [00:10<00:00,  1.28it/s, AUC=0.714, acc=0.392, specificity=0.838, val_loss=1.54938394]\n",
      "Training Epoch [4/20]: 100%|| 459/459 [08:04<00:00,  1.06s/it, AUC=0.789, acc=0.545, complete_loss=62.1383, sensivity=0.46, specificity=0.863, train_loss=1.0733]\n",
      "Validation Epoch [4/20]: 100%|| 13/13 [00:10<00:00,  1.28it/s, AUC=0.784, acc=0.544, specificity=0.871, val_loss=1.08829267]\n",
      "Training Epoch [5/20]: 100%|| 459/459 [08:03<00:00,  1.05s/it, AUC=0.8, acc=0.556, complete_loss=42.0561, sensivity=0.504, specificity=0.866, train_loss=1.0432]\n",
      "Validation Epoch [5/20]: 100%|| 13/13 [00:09<00:00,  1.31it/s, AUC=0.798, acc=0.54, specificity=0.857, val_loss=1.13012947]\n",
      "Training Epoch [6/20]: 100%|| 459/459 [08:05<00:00,  1.06s/it, AUC=0.806, acc=0.565, complete_loss=28.2881, sensivity=0.516, specificity=0.869, train_loss=1.0277]\n",
      "Validation Epoch [6/20]:   0%|                                                                                                                                                   | 0/13 [00:00<?, ?it/s]/usr/local/lib/python3.10/dist-packages/torchmetrics/utilities/prints.py:43: UserWarning: No positive samples in targets, true positive value should be meaningless. Returning zero tensor in true positive score\n",
      "  warnings.warn(*args, **kwargs)  # noqa: B028\n",
      "Validation Epoch [6/20]: 100%|| 13/13 [00:09<00:00,  1.32it/s, AUC=0.703, acc=0.383, specificity=0.845, val_loss=1.56544522]\n",
      "Training Epoch [7/20]: 100%|| 459/459 [08:04<00:00,  1.05s/it, AUC=0.815, acc=0.573, complete_loss=18.9908, sensivity=0.529, specificity=0.871, train_loss=1.0086]\n",
      "Validation Epoch [7/20]: 100%|| 13/13 [00:09<00:00,  1.32it/s, AUC=0.736, acc=0.423, specificity=0.811, val_loss=1.29456122]\n",
      "Training Epoch [8/20]: 100%|| 459/459 [08:01<00:00,  1.05s/it, AUC=0.819, acc=0.578, complete_loss=12.8489, sensivity=0.539, specificity=0.873, train_loss=0.9948]\n",
      "Validation Epoch [8/20]: 100%|| 13/13 [00:09<00:00,  1.36it/s, AUC=0.781, acc=0.414, specificity=0.844, val_loss=1.36887429]\n",
      "Training Epoch [9/20]: 100%|| 459/459 [08:03<00:00,  1.05s/it, AUC=0.824, acc=0.585, complete_loss=8.8810, sensivity=0.548, specificity=0.875, train_loss=0.9808]\n",
      "Validation Epoch [9/20]: 100%|| 13/13 [00:09<00:00,  1.34it/s, AUC=0.747, acc=0.444, specificity=0.817, val_loss=1.24573899]\n",
      "Training Epoch [10/20]: 100%|| 459/459 [08:03<00:00,  1.05s/it, AUC=0.828, acc=0.588, complete_loss=6.3739, sensivity=0.555, specificity=0.876, train_loss=0.9706]\n",
      "Validation Epoch [10/20]: 100%|| 13/13 [00:09<00:00,  1.37it/s, AUC=0.825, acc=0.564, specificity=0.871, val_loss=1.05200152]\n",
      "Training Epoch [11/20]: 100%|| 459/459 [07:57<00:00,  1.04s/it, AUC=0.832, acc=0.594, complete_loss=4.8065, sensivity=0.564, specificity=0.878, train_loss=0.9560]\n",
      "Validation Epoch [11/20]: 100%|| 13/13 [00:09<00:00,  1.40it/s, AUC=0.812, acc=0.544, specificity=0.865, val_loss=1.08018095]\n",
      "Training Epoch [12/20]: 100%|| 459/459 [07:56<00:00,  1.04s/it, AUC=0.835, acc=0.597, complete_loss=3.8395, sensivity=0.569, specificity=0.879, train_loss=0.9528]\n",
      "Validation Epoch [12/20]: 100%|| 13/13 [00:09<00:00,  1.32it/s, AUC=0.818, acc=0.567, specificity=0.873, val_loss=1.03864965]\n",
      "Training Epoch [13/20]: 100%|| 459/459 [07:57<00:00,  1.04s/it, AUC=0.858, acc=0.628, complete_loss=3.3844, sensivity=0.608, specificity=0.888, train_loss=0.8807]\n",
      "Validation Epoch [13/20]: 100%|| 13/13 [00:09<00:00,  1.35it/s, AUC=0.869, acc=0.635, specificity=0.892, val_loss=0.87338958]\n",
      "Training Epoch [14/20]: 100%|| 459/459 [07:57<00:00,  1.04s/it, AUC=0.867, acc=0.64, complete_loss=3.2904, sensivity=0.627, specificity=0.892, train_loss=0.8513]\n",
      "Validation Epoch [14/20]: 100%|| 13/13 [00:09<00:00,  1.38it/s, AUC=0.87, acc=0.632, specificity=0.891, val_loss=0.87149548]\n",
      "Training Epoch [15/20]: 100%|| 459/459 [07:56<00:00,  1.04s/it, AUC=0.871, acc=0.646, complete_loss=3.2132, sensivity=0.628, specificity=0.894, train_loss=0.8392]\n",
      "Validation Epoch [15/20]: 100%|| 13/13 [00:09<00:00,  1.39it/s, AUC=0.871, acc=0.629, specificity=0.893, val_loss=0.88072075]\n",
      "Training Epoch [16/20]: 100%|| 459/459 [07:59<00:00,  1.04s/it, AUC=0.875, acc=0.655, complete_loss=3.1323, sensivity=0.64, specificity=0.896, train_loss=0.8222]\n",
      "Validation Epoch [16/20]: 100%|| 13/13 [00:09<00:00,  1.32it/s, AUC=0.868, acc=0.649, specificity=0.897, val_loss=0.89263528]\n",
      "Training Epoch [17/20]: 100%|| 459/459 [08:02<00:00,  1.05s/it, AUC=0.878, acc=0.657, complete_loss=3.0607, sensivity=0.642, specificity=0.897, train_loss=0.8122]\n",
      "Validation Epoch [17/20]: 100%|| 13/13 [00:09<00:00,  1.35it/s, AUC=0.859, acc=0.613, specificity=0.877, val_loss=0.94439260]\n",
      "Training Epoch [18/20]: 100%|| 459/459 [08:04<00:00,  1.06s/it, AUC=0.881, acc=0.662, complete_loss=2.9886, sensivity=0.649, specificity=0.899, train_loss=0.7984]\n",
      "Validation Epoch [18/20]: 100%|| 13/13 [00:09<00:00,  1.36it/s, AUC=0.878, acc=0.649, specificity=0.894, val_loss=0.83097980]\n",
      "Training Epoch [19/20]: 100%|| 459/459 [08:04<00:00,  1.06s/it, AUC=0.885, acc=0.668, complete_loss=2.9209, sensivity=0.656, specificity=0.901, train_loss=0.7849]\n",
      "Validation Epoch [19/20]: 100%|| 13/13 [00:09<00:00,  1.32it/s, AUC=0.868, acc=0.642, specificity=0.888, val_loss=0.92872760]\n",
      "Training Epoch [20/20]: 100%|| 459/459 [07:57<00:00,  1.04s/it, AUC=0.888, acc=0.675, complete_loss=2.8586, sensivity=0.66, specificity=0.903, train_loss=0.7725]\n",
      "Validation Epoch [20/20]: 100%|| 13/13 [00:09<00:00,  1.36it/s, AUC=0.861, acc=0.617, specificity=0.88, val_loss=0.96487949]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test model ResNet50Model - Loss: 0.96, ACC: 0.62, AUC: 0.86, Sensivility: 0.56, Specificity: 0.64\n"
     ]
    },
    {
     "data": {
      "image/png": "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sLGxgaamJgYPHoyFCxeK9UhEREREVAASQRAEsYMoauqNx4odQqn1/vJ6sUMotTIyy9yXUrEpJy0ZvxjTt0VNwX/yUG82+fOdvkLy5VUKvT4RERERlW6s8CEiIlIEBW/LTkRERESUH/40SkRERERERERUxrDCh4iISBFKyBo+RERERPRt4oAPERGRInBKFxERERGJiD+NEhERERERERGVMazwISIiUgRO6SIiIiIiEbHCh4iIiIiIiIiojGGFDxERkSJwDR8iIiIiEhF/GiUiIiIiIiIiKmNY4UNERKQIXMOHiIiIiETECh8iIiIiIiIiojKGFT5ERESKwDV8iIiIiEhEHPAhIiJSBE7pIiIiIiIR8c+PRERERERERERlDCt8iIiIFIFTuoiIiIhIRPxplIiIiIiIiIiojGGFDxERkSKwwoeIiIiIRMSfRomIiIiIiIiIyhhW+BARESmCEnfpIiIiIiLxsMKHiIiIiIiIiKiMYYUPERGRInANHyIiIiISEQd8iIiIFEHCKV1EREREJB7++ZGIiIiIiIiIqIxhhQ8REZEicEoXEREREYmIP40SEREREREREZUxrPAhIiJSBK7hQ0REREQiYoUPEREREREREVEZwwofIiIiReAaPkREREQkIv40SkRERERERERUxrDCh4iISBG4hg8RERERiYgDPkRERIrAKV1EREREJCL+NEpEREREREREVMawwqcIjOhljxE9HVCtoj4AIPy/11iy5ShOnL8DAFBVKYdlk7ujl6s1VFXK4VRIOCYs+Qtvo+Nl1/h5Wk+0bFgD9Wqa4u7jN2jZd5koz1JS7d7pi+3e2xAVFYnadSwwY9YPaGBlJXZYJVrn9i549fJljvZeffpjxuy5IkRU+vB9V3jMHTili4iIiIhExQqfIhDxJgY//HIQtgOWw27ACgRcug+/1SNhWcMEALB8Sg90cqyPAdO2od3wNTA11MXun4fnuM4fBy9g74lrxR1+iXfs6BGsXL4Uo8Z4YbffAdSpY4HRo4bh3bt3YodWov25cy+Onzkre23Y8jsAoE07V5EjKx34vis85o6IiIiISHwc8CkCR4Ju4fi5O3j0LBIPn73F/F//QUJSKppbmUFHSw2e7jaYvmo/Ai/fx/Xw5xg5bwdsGpmjeYPqsmt8v3wvNu8JwuMX/IXoU39u90b3nr3h3q0HzGvWxJx5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nMWaGT/vXuv1knst1lxzxWG45rrvGzDTdRV87Ha7hg4dKqvVKknKz8/X//zP/8jPz6/YdcuXL3dehAAAACgTq1atUnp6utlhuK1NmzZJIo83ijw6D7l0DvLoHOTROQ4fPnzN117Xos0PP/zwNV23YMGCaw7ACCzaXHos2lx6LNpceizaXHqsE1N6Ri/a/OzqHw29/6vd6xt6f9xctmzZorZt26qwsNDsUNyel5eXYytklB55dB5y6Rzk0TnIo3N4e3tr48aNio6OLvG663q5a3YhBwAAAM5ntVpVWFioRYsWqUGDBmaH47ZWrVql559/njzeIPLoPOTSOcijc5BH50hPT9egQYMcM69KYvD7mwAA3JzovoI7atCgAVvl3oDfpyiQxxtDHp2HXDoHeXQO8lj2WFMSAAAAAADAw9DhAwCAAWjwAQAAgJno8AEAwABeFmMPwJ1t3rxZMTExat++vTp27KidO3dq4cKFmjVrltMeY/78+Wrbtq1atmypSZMmOe2+7uKZZ55R27ZtNXjwYBUUFDjGf/vtN/Xs2VPt27dXp06dlJmZKUk6duyY/vKXv6hDhw6aMmWKWWG7nD/KoyQtWbJEHTt2VExMjLZs2aLffvtNMTExiomJ0T333KO77rrLpKhdzx/lMTEx0ZGz8PBwzZgxQ5JUr149x/i6devMCtvl/FEec3JyHN+/48ePd4xPnjxZLVu2VMuWLfX111+bEbLLys7O1j333CN/f399//33kqSlS5eqVatW6tSpk44dOyZJGjFihFq1aqWWLVu65dciBR8AAACUmTNnzmjkyJH65JNPlJKSosTERHl5Of8l6aBBg7Rx40Zt3bpVW7Zscbx4vxns2bNHx48f18aNGxUREaFly5Y5zq1evVp33nmnUlJSNHToUH344YeSpPHjx2vOnDnasGGDXnrpJbNCdykl5fHEiRNasWKFkpKSlJycrOjoaFWoUEHJyclKTk7W448/rt69e5sXvAspKY/333+/I2d16tRx5CwwMNAx3rlzZ5Midy0l5fH9999Xr169tGHDBuXl5Wn79u06c+aMNmzYoK1bt2rp0qWaOnWqidG7nooVK2rlypXq27evJOnSpUt66623lJycrKlTp+rll1+WdLnItnnzZq1evVrPPvusmSGXCgUfAAAM4GWxGHoA7mrlypXq3bu3qlevLunyH3b/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\n",
      "text/plain": [
       "<Figure size 1400x600 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Primera prueba para ver el entrenamiento\n",
    "# He probado antes en local para ver como alcanzaba un 100% de acc y 0.001 de loss con pocos datos\n",
    "train_model(model, trainer, train_dataset, val_dataset, epochs=20, device=device, save_model = \"experimento1.2\", name=\"Experimento1.3\", wdb=True, local=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d7b81ab0",
   "metadata": {
    "papermill": {
     "duration": 1.00476,
     "end_time": "2025-03-04T19:38:09.920303",
     "exception": false,
     "start_time": "2025-03-04T19:38:08.915543",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "gpu",
   "dataSources": [
    {
     "datasetId": 6786867,
     "sourceId": 10917159,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30919,
   "isGpuEnabled": true,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 10065.815017,
   "end_time": "2025-03-04T19:38:13.464985",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-03-04T16:50:27.649968",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
