{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "910da8d3",
   "metadata": {
    "papermill": {
     "duration": 0.004291,
     "end_time": "2025-03-07T21:39:09.957627",
     "exception": false,
     "start_time": "2025-03-07T21:39:09.953336",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "cdb235af",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:09.965701Z",
     "iopub.status.busy": "2025-03-07T21:39:09.965384Z",
     "iopub.status.idle": "2025-03-07T21:39:17.757440Z",
     "shell.execute_reply": "2025-03-07T21:39:17.756740Z"
    },
    "papermill": {
     "duration": 7.797708,
     "end_time": "2025-03-07T21:39:17.759020",
     "exception": false,
     "start_time": "2025-03-07T21:39:09.961312",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import cv2\n",
    "import numpy as np\n",
    "import torch\n",
    "from PIL import Image\n",
    "from torchvision import transforms\n",
    "\n",
    "class HistogramEqualization:\n",
    "    \"\"\"Aplica ecualizaci贸n de histograma para ajuste de contraste\"\"\"\n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar ecualizaci贸n de histograma por canal\n",
    "        if len(img_np.shape) == 3:  # Imagen RGB\n",
    "            img_eq = np.zeros_like(img_np)\n",
    "            for i in range(3):\n",
    "                img_eq[:,:,i] = cv2.equalizeHist(img_np[:,:,i])\n",
    "        else:  # Imagen en escala de grises\n",
    "            img_eq = cv2.equalizeHist(img_np)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_eq)\n",
    "\n",
    "class BilateralFilter:\n",
    "    \"\"\"Aplica filtrado bilateral para suavizado preservando bordes\"\"\"\n",
    "    def __init__(self, d=9, sigma_color=75, sigma_space=75):\n",
    "        self.d = d  # Di谩metro de cada vecindario de p铆xeles\n",
    "        self.sigma_color = sigma_color  # Filtro sigma en el espacio de color\n",
    "        self.sigma_space = sigma_space  # Filtro sigma en el espacio de coordenadas\n",
    "    \n",
    "    def __call__(self, img):\n",
    "        # Convertir PIL Image a numpy array\n",
    "        img_np = np.array(img)\n",
    "        \n",
    "        # Aplicar filtro bilateral\n",
    "        img_filtered = cv2.bilateralFilter(\n",
    "            img_np, self.d, self.sigma_color, self.sigma_space)\n",
    "            \n",
    "        # Convertir de nuevo a PIL Image\n",
    "        return Image.fromarray(img_filtered)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "f202d82d",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:17.766506Z",
     "iopub.status.busy": "2025-03-07T21:39:17.766180Z",
     "iopub.status.idle": "2025-03-07T21:39:17.776718Z",
     "shell.execute_reply": "2025-03-07T21:39:17.776091Z"
    },
    "papermill": {
     "duration": 0.015494,
     "end_time": "2025-03-07T21:39:17.777908",
     "exception": false,
     "start_time": "2025-03-07T21:39:17.762414",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "class DatasetExperiment1(Dataset):\n",
    "    def __init__(self, mode='train', batch_size=32,grey = False, local = False, path = ''):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            mode (str): 'train', 'val' o 'test'.\n",
    "            transform: Transformaciones de torchvision a aplicar a las im谩genes.\n",
    "        \"\"\"\n",
    "        assert mode in ['train', 'val', 'test'], \"Mode must be 'train', 'val', or 'test'\"\n",
    "        if local:\n",
    "            print(\"LOCAL MODE ENABLED\")\n",
    "        self.grey = grey\n",
    "        # Transformaciones del paper\n",
    "        # Histogram equalization for contrast adjustment\n",
    "        # and bilateral filtering for smoothness\n",
    "        self.transform =  transforms.Compose([\n",
    "            transforms.Resize((224, 224)),\n",
    "            HistogramEqualization(),\n",
    "            BilateralFilter(d=9, sigma_color=75, sigma_space=75),\n",
    "            transforms.ToTensor(),\n",
    "        ])\n",
    "        self.data_path = os.path.join(path, mode)\n",
    "        self.classes = sorted(os.listdir(self.data_path))  # Lista de clases\n",
    "        self.data = []\n",
    "        self.batch_size = batch_size\n",
    "        # Cargar im谩genes con sus etiquetas\n",
    "        \n",
    "\n",
    "        for label, class_name in enumerate(self.classes):\n",
    "            class_path = os.path.join(self.data_path, class_name)\n",
    "            i = 0\n",
    "            for img_name in os.listdir(class_path):\n",
    "                if local and i >= 3:\n",
    "                    break\n",
    "                img_path = os.path.join(class_path, img_name)\n",
    "                self.data.append((img_path, label))\n",
    "                i += 1\n",
    "    def __len__(self):\n",
    "        return len(self.data)\n",
    "    \n",
    "    def __getitem__(self, idx):\n",
    "        img_path, label = self.data[idx]\n",
    "        if not self.grey:\n",
    "            image = Image.open(img_path).convert('RGB')\n",
    "        else:\n",
    "            image = Image.open(img_path).convert('L')\n",
    "        if self.transform:\n",
    "            image = self.transform(image)\n",
    "        \n",
    "        return image, label\n",
    "    \n",
    "    def get_dataloader(self, shuffle=True):       \n",
    "        return DataLoader(self, batch_size=self.batch_size, shuffle=shuffle)\n",
    "    def show_image(self, idx, transformed=True, figsize=(10, 8)):\n",
    "        \"\"\"\n",
    "        Muestra una imagen del dataset con su etiqueta\n",
    "        \n",
    "        Args:\n",
    "            idx (int): ndice de la imagen a mostrar\n",
    "            transformed (bool): Si es True, muestra la imagen transformada. \n",
    "                               Si es False, muestra la imagen original.\n",
    "            figsize (tuple): Tama帽o de la figura (ancho, alto)\n",
    "        \"\"\"\n",
    "        if idx >= len(self):\n",
    "            print(f\"ndice {idx} fuera de rango. El dataset tiene {len(self)} elementos.\")\n",
    "            return\n",
    "        \n",
    "        img_path, label = self.data[idx]\n",
    "        class_name = self.classes[label]\n",
    "        \n",
    "        plt.figure(figsize=figsize)\n",
    "        \n",
    "        # Mostrar imagen original\n",
    "        orig_img = Image.open(img_path).convert('RGB')\n",
    "        plt.subplot(1, 2, 1)\n",
    "        plt.imshow(orig_img)\n",
    "        plt.title(f\"Original: Clase {class_name} (label {label})\")\n",
    "        plt.axis('off')\n",
    "        \n",
    "        # Mostrar imagen transformada si se solicita\n",
    "        if transformed:\n",
    "            trans_img = self.transform(orig_img)\n",
    "            # Convertir tensor a numpy para visualizaci贸n\n",
    "            if isinstance(trans_img, torch.Tensor):\n",
    "                trans_img = trans_img.permute(1, 2, 0).numpy()  # Cambiar de CxHxW a HxWxC\n",
    "                # Normalizar valores para visualizaci贸n\n",
    "                trans_img = np.clip(trans_img, 0, 1)\n",
    "            \n",
    "            plt.subplot(1, 2, 2)\n",
    "            plt.imshow(trans_img)\n",
    "            plt.title(\"Con transformaciones aplicadas\")\n",
    "            plt.axis('off')\n",
    "        \n",
    "        plt.tight_layout()\n",
    "        plt.show()\n",
    "        \n",
    "        # Imprimir informaci贸n adicional\n",
    "        print(f\"Ruta de la imagen: {img_path}\")\n",
    "        print(f\"Clase: {class_name} (label {label})\")\n",
    "        print(f\"Resoluci贸n original: {orig_img.size}\")\n",
    "        if transformed and isinstance(trans_img, np.ndarray):\n",
    "            print(f\"Resoluci贸n despu茅s de transformaciones: {trans_img.shape[:2]}\")\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3c36495c",
   "metadata": {
    "papermill": {
     "duration": 0.002819,
     "end_time": "2025-03-07T21:39:17.783812",
     "exception": false,
     "start_time": "2025-03-07T21:39:17.780993",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Train config 1"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "83067c3e",
   "metadata": {
    "papermill": {
     "duration": 0.002832,
     "end_time": "2025-03-07T21:39:17.789611",
     "exception": false,
     "start_time": "2025-03-07T21:39:17.786779",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "The hyperparameters of the proposed ensemble model were\n",
    "tuned by the trial-and-error method. \n",
    "L2 regularization, \n",
    "batch normalization, \n",
    "dropout rate\n",
    "\n",
    "The Adam optimizer\n",
    "Epochs = 150. \n",
    "The learning rate scheduler and ReduceLROnPlateau were used for handling\n",
    "the learning rate with an initial value of 0.001. The loss\n",
    "function used for the model was categorical cross-entropy"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7b616c9",
   "metadata": {
    "papermill": {
     "duration": 0.002735,
     "end_time": "2025-03-07T21:39:17.795315",
     "exception": false,
     "start_time": "2025-03-07T21:39:17.792580",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Trainer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "f4d13d47",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:17.802268Z",
     "iopub.status.busy": "2025-03-07T21:39:17.802000Z",
     "iopub.status.idle": "2025-03-07T21:39:26.549389Z",
     "shell.execute_reply": "2025-03-07T21:39:26.548637Z"
    },
    "papermill": {
     "duration": 8.752906,
     "end_time": "2025-03-07T21:39:26.551131",
     "exception": false,
     "start_time": "2025-03-07T21:39:17.798225",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "!pip install -q lightning\n",
    "import lightning.pytorch as pl\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torchmetrics as tm\n",
    "from torchmetrics.classification import MulticlassConfusionMatrix\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "\n",
    "class Classification(pl.LightningModule):\n",
    "    \"\"\"\n",
    "    Trainer para entrenar un modelo de clasificaci贸n multiclase\n",
    "    y de dimension 1 con valores [0, num_classes]\n",
    "    \"\"\"\n",
    "    def __init__(self, model, device, L1=0.001, L2=0.001, lr=0.001, patience=5, factor=0.1, betas=(0.9, 0.999)):\n",
    "        super().__init__()\n",
    "        self.save_hyperparameters(ignore=(\"model\",))\n",
    "\n",
    "        self.model = model\n",
    "\n",
    "        self.loss_fn = nn.CrossEntropyLoss()\n",
    "        self.L1 = L1\n",
    "        self.L2 = L2\n",
    "        self.learning_rate = lr\n",
    "        self.patience = patience\n",
    "        self.factor = factor\n",
    "        self.betas = betas\n",
    "\n",
    "        self.num_classes = 5\n",
    "        self.confusion_matrix = MulticlassConfusionMatrix(num_classes=5).to(device)\n",
    "        self.auc_metric = tm.AUROC(num_classes=5, task=\"multiclass\").to(device)  # Definir m茅trica AUROC para clasificaci贸n multiclase\n",
    "\n",
    "    def forward(self, x):\n",
    "        return self.model(x)\n",
    "\n",
    "    def training_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        \n",
    "        # Regularizaci贸n L1\n",
    "        L1_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L1_reg = L1_reg + torch.sum(torch.abs(param))\n",
    "        \n",
    "        # Regularizaci贸n L2\n",
    "        L2_reg = torch.tensor(0., requires_grad=True)\n",
    "        for param in self.model.parameters():\n",
    "            L2_reg = L2_reg + torch.sum(param ** 2)\n",
    "        \n",
    "        # A帽adir regularizaci贸n a la p茅rdida\n",
    "        prediction_loss = loss\n",
    "        loss = loss + self.L1 * L1_reg + self.L2 * L2_reg\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular m茅tricas\n",
    "        loss.backward()\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "\n",
    "        return {\"loss\": prediction_loss, \"real_loss\": loss, \"ACC\": ACC, \"recall\": recall, \"precision\": precision, \"f1_score\": f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def validation_step(self, x, y):\n",
    "        y = y\n",
    "        y_hat = self.model(x)\n",
    "        y_oh = self.transform_classes(y)\n",
    "        loss = self.loss_fn(y_hat, y_oh)\n",
    "        # Obtener la clase predicha\n",
    "        y_pred = torch.argmax(y_hat, dim=1)\n",
    "        # Calcular m茅tricas\n",
    "        self.confusion_matrix.update(y_pred, y)\n",
    "        self.auc_metric.update(y_hat, y)\n",
    "\n",
    "        precision, recall, f1_score, ACC, AUC, specificity = self.calculate_metrics_from_confusion_matrix()\n",
    "        return {\"loss\": loss, \"ACC\": ACC, \"precision\" : precision, \"recall\": recall, \"f1_score\" : f1_score, \"AUC\": AUC, \"specificity\": specificity}\n",
    "\n",
    "    def transform_classes(self, y):\n",
    "        # Convertir las clases a un formato de one-hot encoding\n",
    "        return torch.nn.functional.one_hot(y.to(torch.int64), num_classes=5).to(float).squeeze()\n",
    "    def restart_epoch(self, plot = False):\n",
    "        if plot:\n",
    "            self.plot()\n",
    "        self.confusion_matrix.reset()\n",
    "        self.auc_metric.reset()\n",
    "    def calculate_metrics_from_confusion_matrix(self):\n",
    "        # Obtener la matriz de confusi贸n (suponiendo que es un tensor de torch)\n",
    "        cm = self.confusion_matrix.compute()\n",
    "        total_samples = cm.sum()\n",
    "        \n",
    "        # Verdaderos positivos por clase (diagonal de la matriz)\n",
    "        true_positives = torch.diag(cm)\n",
    "        \n",
    "        # Predicciones totales por clase (sumar columnas)\n",
    "        predicted_positives = cm.sum(dim=0)\n",
    "        \n",
    "        # Ejemplos reales por clase (sumar filas)\n",
    "        actual_positives = cm.sum(dim=1)\n",
    "        \n",
    "        # Calcular falsos positivos y falsos negativos por clase\n",
    "        false_positives = predicted_positives - true_positives\n",
    "        false_negatives = actual_positives - true_positives\n",
    "        \n",
    "        # Calcular verdaderos negativos por clase\n",
    "        true_negatives = total_samples - (actual_positives + predicted_positives - true_positives)\n",
    "        \n",
    "        # Calcular m茅tricas por clase con robustez para evitar divisi贸n por cero\n",
    "        precision_per_class = true_positives / (predicted_positives + 1e-8)\n",
    "        recall_per_class = true_positives / (actual_positives + 1e-8)\n",
    "        specificity_per_class = true_negatives / (true_negatives + false_positives + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # Promediar las m茅tricas por clase\n",
    "        precision = precision_per_class.mean()\n",
    "        recall = recall_per_class.mean()\n",
    "        specificity = specificity_per_class.mean()\n",
    "        f1 = f1_per_class.mean()\n",
    "        \n",
    "        # Calcular Accuracy (exactitud)\n",
    "        ACC = true_positives.sum() / total_samples\n",
    "        \n",
    "        # Calcular el AUC (suponiendo que self.auc_metric ya est谩 correctamente definido)\n",
    "        AUC = self.auc_metric.compute()\n",
    "        \n",
    "        return precision, recall, f1, ACC, AUC, specificity\n",
    "\n",
    "\n",
    "    def configure_optimizers(self):\n",
    "        optimizer = torch.optim.Adam(self.model.parameters(),\n",
    "                                     lr=self.learning_rate,\n",
    "                                     betas=self.betas)\n",
    "        scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer=optimizer,\n",
    "                                                               factor=self.factor,\n",
    "                                                               patience=self.patience)\n",
    "        return optimizer, scheduler\n",
    "    def plot(self, epoch=0):\n",
    "        # Computa la matriz de confusi贸n y las m茅tricas por clase\n",
    "        cm = self.confusion_matrix.compute().cpu().numpy()\n",
    "        support = cm.sum(axis=1)\n",
    "        precision_per_class = np.diag(cm) / (cm.sum(axis=0) + 1e-8)\n",
    "        recall_per_class = np.diag(cm) / (cm.sum(axis=1) + 1e-8)\n",
    "        f1_per_class = 2 * (precision_per_class * recall_per_class) / (precision_per_class + recall_per_class + 1e-8)\n",
    "        \n",
    "        # C谩lculo de especificidad por clase\n",
    "        FP = cm.sum(axis=0) - np.diag(cm)\n",
    "        FN = cm.sum(axis=1) - np.diag(cm)\n",
    "        TN = cm.sum() - (FP + FN + np.diag(cm))\n",
    "        specificity_per_class = TN / (TN + FP + 1e-8)\n",
    "        \n",
    "        accuracy = np.diag(cm).sum() / cm.sum()\n",
    "\n",
    "        # Crea dos subplots: uno para la matriz de confusi贸n y otro para la tabla de m茅tricas\n",
    "        fig, axs = plt.subplots(1, 2, figsize=(14, 6))\n",
    "\n",
    "        # Subplot 1: Matriz de confusi贸n con heatmap\n",
    "        sns.heatmap(cm, annot=True, fmt=\"d\", ax=axs[0], cmap=\"Blues\")\n",
    "        axs[0].set_title(\"Matriz de Confusi贸n epoch \" + str(epoch))\n",
    "        axs[0].set_xlabel(\"Predicci贸n\")\n",
    "        axs[0].set_ylabel(\"Real\")\n",
    "\n",
    "        # Subplot 2: Tabla de m茅tricas por clase\n",
    "        table_data = []\n",
    "        for i in range(self.num_classes):\n",
    "            table_data.append([f\"Clase {i}\",\n",
    "                            f\"{precision_per_class[i]:.2f}\",\n",
    "                            f\"{recall_per_class[i]:.2f}\",\n",
    "                            f\"{f1_per_class[i]:.2f}\",\n",
    "                            f\"{specificity_per_class[i]:.2f}\",\n",
    "                            int(support[i])])\n",
    "        axs[1].axis('tight')\n",
    "        axs[1].axis('off')\n",
    "        table = axs[1].table(cellText=table_data,\n",
    "                            colLabels=[\"Clase\", \"Precision\", \"Sensivity/Recall\", \"F1\", \"Specificity\", \"Support\"],\n",
    "                            cellLoc=\"center\", loc=\"center\")\n",
    "        axs[1].set_title(f\"Metrics por clase\\nAccuracy General: {accuracy:.2f}\", pad=20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "37482b45",
   "metadata": {
    "papermill": {
     "duration": 0.003054,
     "end_time": "2025-03-07T21:39:26.557699",
     "exception": false,
     "start_time": "2025-03-07T21:39:26.554645",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "a6e5d590",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:26.564971Z",
     "iopub.status.busy": "2025-03-07T21:39:26.564502Z",
     "iopub.status.idle": "2025-03-07T21:39:26.572019Z",
     "shell.execute_reply": "2025-03-07T21:39:26.571211Z"
    },
    "papermill": {
     "duration": 0.01278,
     "end_time": "2025-03-07T21:39:26.573449",
     "exception": false,
     "start_time": "2025-03-07T21:39:26.560669",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "import torch.nn as nn\n",
    "from torch.nn import functional as F\n",
    "import torchvision.models as models\n",
    "\n",
    "class ResNet50Model(nn.Module):\n",
    "    \"\"\"\n",
    "    Modelo basado en ResNet50 para la clasificaci贸n de radiograf铆as.\n",
    "    Permite personalizaci贸n en el n煤mero de clases y si se usa transfer learning.\n",
    "    \"\"\"\n",
    "    def __init__(self, num_classes=5, pretrained=True, grey = False, dropout_rate=0.3):\n",
    "        \"\"\"\n",
    "        Inicializa el modelo ResNet50.\n",
    "        \n",
    "        Args:\n",
    "            num_classes (int): N煤mero de clases para la clasificaci贸n (default: 5)\n",
    "            pretrained (bool): Si se deben usar pesos preentrenados en ImageNet (default: True)\n",
    "            freeze_backbone (bool): Si se deben congelar las capas de la red base (default: False)\n",
    "            dropout_rate (float): Tasa de dropout aplicada antes de la capa de clasificaci贸n (default: 0.3)\n",
    "        \"\"\"\n",
    "        super(ResNet50Model, self).__init__()\n",
    "        \n",
    "        # Cargar el modelo base ResNet50\n",
    "        self.model = models.resnet50(weights='IMAGENET1K_V2' if pretrained else None)\n",
    "        \n",
    "        # Nombre del modelo para identificaci贸n\n",
    "        self.name = \"ResNet50\"\n",
    "        \n",
    "        \n",
    "        # Reemplazar la capa de clasificaci贸n final\n",
    "        in_features = self.model.fc.in_features\n",
    "        self.model.fc = nn.Sequential(\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(in_features, 512),\n",
    "            nn.ReLU(),\n",
    "            nn.Dropout(dropout_rate),\n",
    "            nn.Linear(512, num_classes)\n",
    "        )\n",
    "        if grey:\n",
    "            # Guardamos la capa original\n",
    "            original_conv = self.model.conv1\n",
    "            # Creamos una nueva capa que acepte 1 canal de entrada\n",
    "            self.model.conv1 = nn.Conv2d(\n",
    "                in_channels=1, \n",
    "                out_channels=original_conv.out_channels, \n",
    "                kernel_size=original_conv.kernel_size, \n",
    "                stride=original_conv.stride, \n",
    "                padding=original_conv.padding, \n",
    "                bias=False\n",
    "            )\n",
    "            if pretrained:\n",
    "                # Inicializamos los pesos promediando los de los 3 canales originales\n",
    "                self.model.conv1.weight.data = original_conv.weight.data.mean(dim=1, keepdim=True)\n",
    "        \n",
    "    \n",
    "    def forward(self, x):\n",
    "        \"\"\"\n",
    "        Propagaci贸n hacia adelante a trav茅s del modelo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor con las predicciones de clase [batch_size, num_classes]\n",
    "        \"\"\"\n",
    "        return self.model(x)\n",
    "    \n",
    "    def get_features(self, x):\n",
    "        \"\"\"\n",
    "        Obtiene los features del modelo antes de la capa de clasificaci贸n.\n",
    "        til para an谩lisis de caracter铆sticas o transferencia de estilo.\n",
    "        \n",
    "        Args:\n",
    "            x: Tensor de entrada con forma [batch_size, channels, height, width]\n",
    "            \n",
    "        Returns:\n",
    "            Tensor de caracter铆sticas [batch_size, 2048]\n",
    "        \"\"\"\n",
    "        # Extrae todas las capas excepto la final\n",
    "        modules = list(self.model.children())[:-1]\n",
    "        feature_extractor = nn.Sequential(*modules)\n",
    "        \n",
    "        # Obtiene los features y los aplana\n",
    "        features = feature_extractor(x)\n",
    "        features = features.view(features.size(0), -1)\n",
    "        \n",
    "        return features\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e83b1338",
   "metadata": {
    "papermill": {
     "duration": 0.002881,
     "end_time": "2025-03-07T21:39:26.579595",
     "exception": false,
     "start_time": "2025-03-07T21:39:26.576714",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "## Train function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "27477db5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:26.586815Z",
     "iopub.status.busy": "2025-03-07T21:39:26.586530Z",
     "iopub.status.idle": "2025-03-07T21:39:28.465496Z",
     "shell.execute_reply": "2025-03-07T21:39:28.464789Z"
    },
    "papermill": {
     "duration": 1.884323,
     "end_time": "2025-03-07T21:39:28.466990",
     "exception": false,
     "start_time": "2025-03-07T21:39:26.582667",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import torch\n",
    "from tqdm import tqdm\n",
    "from wandb import wandb\n",
    "\n",
    "def create_tqdm_bar(iterable, desc, mode):\n",
    "    return tqdm(enumerate(iterable),total=len(iterable), ncols=200, desc=desc)\n",
    "\n",
    "def train_model(model, trainer, train_dataset, val_dataset, epochs=5, transform=None, device='cuda', save_model = \"\", name=\"Test\", wdb=True, local=False, project=\"oai-knee-cartilage-segmentation\"):\n",
    "    if wdb:\n",
    "        if wandb.run is not None:\n",
    "            wandb.finish()\n",
    "        wandb.init(\n",
    "            project=project,\n",
    "            name=name,\n",
    "            # track hyperparameters and run metadata\n",
    "            config={\n",
    "                \"model\": model.name,\n",
    "                \"Batch_size\": train_dataset.batch_size,\n",
    "                \"learning_rate\": trainer.learning_rate,\n",
    "                \"L1\": trainer.L1,\n",
    "                \"L2\": trainer.L2,\n",
    "                \"patience\": trainer.patience,\n",
    "                \"factor\": trainer.factor,\n",
    "                \"betas\": trainer.betas,\n",
    "                \"epochs\": epochs,\n",
    "            }\n",
    "        )\n",
    "    train_loader = train_dataset.get_dataloader(shuffle=True)\n",
    "    val_loader = val_dataset.get_dataloader(shuffle=True)\n",
    "    model.to(device)\n",
    "    train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = local, save_model = save_model)\n",
    "    \n",
    "\n",
    "def train(model, train_loader, val_loader, trainer, epochs, device, wdb, local = False, save_model = \"\"):\n",
    "    \"\"\"\n",
    "    train the given model\n",
    "    \"\"\"\n",
    "    optimizer, scheduler = trainer.configure_optimizers()\n",
    "    best_model = None\n",
    "    best_loss = float('inf')\n",
    "    for epoch in range(epochs):        \n",
    "        training_loss = []\n",
    "        validation_loss = []\n",
    "\n",
    "        training_loss_num = 0\n",
    "        complete_loss_num = 0\n",
    "        validation_loss_num = 0\n",
    "\n",
    "        # use training data\n",
    "        model.train()\n",
    "\n",
    "        training_loop = create_tqdm_bar(train_loader, desc=f'Training Epoch [{epoch + 1}/{epochs}]', mode='train')\n",
    "        for train_iteration, batch in training_loop:\n",
    "            batch = batch[0].to(device), batch[1].to(device)\n",
    "            optimizer.zero_grad()\n",
    "            res = trainer.training_step(batch[0], batch[1])\n",
    "            optimizer.step()\n",
    "\n",
    "            training_loss.append(res['loss'].item())\n",
    "            training_loss_num += res['loss'].item()\n",
    "            complete_loss_num += res['real_loss'].item()\n",
    "            # Update the progress bar.\n",
    "            training_loop.set_postfix(train_loss=\"{:.4f}\".format(training_loss_num / (train_iteration + 1)),\n",
    "                                      complete_loss=\"{:.4f}\".format(complete_loss_num / (train_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      sensivity=res['recall'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "            if wdb:\n",
    "                \n",
    "                wandb.log({\"train_loss\": training_loss_num / (train_iteration + 1),\n",
    "                           \"complete_loss\": complete_loss_num / (train_iteration + 1),\n",
    "                        \"train_acc\": res['ACC'],\n",
    "                        \"train_recall\": res['recall'].item(),\n",
    "                        \"train_precision\": res['precision'].item(),\n",
    "                        \"train_specifity\": res['specificity'].item(),\n",
    "                        \"train_f1_score\": res['f1_score'].item(),\n",
    "                        \"train_AUC\": res['AUC'],\n",
    "                        \"epoch\": epoch,\n",
    "                        \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        trainer.restart_epoch(plot=False)\n",
    "        # use validation data\n",
    "        if local:\n",
    "            continue\n",
    "        model.eval()\n",
    "        val_loop = create_tqdm_bar(val_loader, desc=f'Validation Epoch [{epoch + 1}/{epochs}]', mode='val')\n",
    "        with torch.no_grad():\n",
    "            for val_iteration, batch in val_loop:\n",
    "                batch = batch[0].to(device), batch[1].to(device)\n",
    "                res = trainer.validation_step(batch[0], batch[1])  \n",
    "                validation_loss.append(res['loss'].item())\n",
    "                validation_loss_num += res['loss'].item()\n",
    "                val_loop.set_postfix(val_loss = \"{:.8f}\".format(validation_loss_num / (val_iteration + 1)),\n",
    "                                      acc=res['ACC'].item(),\n",
    "                                      AUC=res['AUC'].item(),\n",
    "                                      specificity=res['specificity'].item())\n",
    "                                      \n",
    "        if wdb:\n",
    "            wandb.log({\"val_loss\": validation_loss_num / (val_iteration + 1),\n",
    "                    \"val_acc\": res['ACC'],\n",
    "                    \"val_recall\": res['recall'].item(),\n",
    "                    \"val_precision\": res['precision'].item(),\n",
    "                    \"val_specificity\": res['specificity'].item(),\n",
    "                    \"val_f1_score\": res['f1_score'].item(),\n",
    "                    \"val_AUC\": res['AUC'],\n",
    "                    \"epoch\": epoch,\n",
    "                    \"learning_rate\": optimizer.param_groups[0]['lr']})\n",
    "        if validation_loss_num < best_loss:\n",
    "            best_loss = validation_loss_num\n",
    "            if save_model != \"\":\n",
    "                torch.save(model.state_dict(), f\"best_model_{model.__class__.__name__}_{save_model}_epoch_{epoch}.pt\")\n",
    "        scheduler.step(validation_loss_num)\n",
    "        trainer.restart_epoch(plot=False)\n",
    "    \n",
    "    test_model(model, val_loader, trainer, device, wdb)\n",
    "\n",
    "def test_model(model, test_loader, trainer, device, wdb=False):\n",
    "    \"\"\"\n",
    "    Test the given model\n",
    "    \"\"\"\n",
    "    model.eval()\n",
    "    model.to(device)\n",
    "\n",
    "    epoch_loss = 0.0\n",
    "    avg_loss = 0.0\n",
    "    trainer.restart_epoch(plot = False)\n",
    "    for batch in test_loader:\n",
    "        inputs, labels = batch\n",
    "        inputs = inputs.to(device)\n",
    "        \n",
    "        labels = labels.to(device)\n",
    "\n",
    "        with torch.no_grad():\n",
    "            res = trainer.validation_step(inputs, labels)\n",
    "            # Extraer valores escalares\n",
    "            loss = res['loss']\n",
    "            \n",
    "        loss_value = loss.item()\n",
    "        # Calcular promedios\n",
    "        epoch_loss += loss_value\n",
    "\n",
    "    ACC_value = res['ACC']\n",
    "    recall_value = res['recall'].item()\n",
    "    precision_value = res['precision'].item()\n",
    "    f1_score_value = res['f1_score'].item()\n",
    "    AUC_value = res['AUC']\n",
    "    avg_loss = epoch_loss / len(test_loader)\n",
    "    if wdb:\n",
    "        wandb.log({\"test_loss\": avg_loss, \"test_acc\": ACC_value.item(),\n",
    "                \"test_recall\": recall_value, \"test_precision\": precision_value,\n",
    "                \"test_f1_score\": f1_score_value, \"test_AUC\" : AUC_value})\n",
    "    \n",
    "    print(f\"Test model {model.__class__.__name__} - Loss: {avg_loss:.2f}, ACC: {ACC_value:.2f}, AUC: {AUC_value:.2f}, Sensivility: {recall_value:.2f}, Specificity: {precision_value:.2f}\")\n",
    "\n",
    "    trainer.restart_epoch(plot = True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "fdd85b4c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:28.474320Z",
     "iopub.status.busy": "2025-03-07T21:39:28.474093Z",
     "iopub.status.idle": "2025-03-07T21:39:29.384827Z",
     "shell.execute_reply": "2025-03-07T21:39:29.384101Z"
    },
    "papermill": {
     "duration": 0.91611,
     "end_time": "2025-03-07T21:39:29.386469",
     "exception": false,
     "start_time": "2025-03-07T21:39:28.470359",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import os\n",
    "from torch.utils.data import DataLoader, Dataset\n",
    "from torchvision import transforms\n",
    "import matplotlib.pyplot as plt\n",
    "BATCH_SIZE = 64\n",
    "LEARNING_RATE = 0.001\n",
    "FACTOR = 0.1\n",
    "L1 = 0.00\n",
    "L2 = 0.00005\n",
    "PATIENCE = 7\n",
    "BETAS=(0.9, 0.999)\n",
    "GREY = True\n",
    "DATASET_PATH = '/kaggle/input/augmented-oai-bright/augmented_oai_bright'\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "train_dataset = DatasetExperiment1('train', batch_size=BATCH_SIZE, local=False,grey=True, path = DATASET_PATH)\n",
    "val_dataset = DatasetExperiment1('val', batch_size=BATCH_SIZE, local=False, grey=True, path = DATASET_PATH)\n",
    "model = ResNet50Model(num_classes=len(train_dataset.classes), dropout_rate=0.5,grey = True, pretrained = False)\n",
    "trainer = Classification(model, device, L1=L1, L2=L2, lr=LEARNING_RATE, patience=PATIENCE, factor=FACTOR, betas=BETAS)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "8db45638",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:29.394173Z",
     "iopub.status.busy": "2025-03-07T21:39:29.393863Z",
     "iopub.status.idle": "2025-03-07T21:39:30.062262Z",
     "shell.execute_reply": "2025-03-07T21:39:30.061380Z"
    },
    "papermill": {
     "duration": 0.673646,
     "end_time": "2025-03-07T21:39:30.063689",
     "exception": false,
     "start_time": "2025-03-07T21:39:29.390043",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Using wandb-core as the SDK backend.  Please refer to https://wandb.me/wandb-core for more information.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Currently logged in as: \u001b[33mchermar\u001b[0m (\u001b[33mchermar-universitat-polit-cnica-de-val-ncia\u001b[0m). Use \u001b[1m`wandb login --relogin`\u001b[0m to force relogin\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m If you're specifying your api key in code, ensure this code is not shared publicly.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: \u001b[33mWARNING\u001b[0m Consider setting the WANDB_API_KEY environment variable, or running `wandb login` from the command line.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Appending key for api.wandb.ai to your netrc file: /root/.netrc\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "wandb.login(key=\"254f72e7bdeec44797ba1b2a91ebbc63900b89f4\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "1c7b19ff",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-03-07T21:39:30.071973Z",
     "iopub.status.busy": "2025-03-07T21:39:30.071715Z",
     "iopub.status.idle": "2025-03-08T00:39:55.213112Z",
     "shell.execute_reply": "2025-03-08T00:39:55.212220Z"
    },
    "papermill": {
     "duration": 10825.949735,
     "end_time": "2025-03-08T00:39:56.017492",
     "exception": false,
     "start_time": "2025-03-07T21:39:30.067757",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\u001b[34m\u001b[1mwandb\u001b[0m: Tracking run with wandb version 0.19.1\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run data is saved locally in \u001b[35m\u001b[1m/kaggle/working/wandb/run-20250307_213930-clxpn0ia\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Run \u001b[1m`wandb offline`\u001b[0m to turn off syncing.\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: Syncing run \u001b[33m-Bright\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m: 猸锔 View project at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation\u001b[0m\n",
      "\u001b[34m\u001b[1mwandb\u001b[0m:  View run at \u001b[34m\u001b[4mhttps://wandb.ai/chermar-universitat-polit-cnica-de-val-ncia/oai-knee-cartilage-segmentation/runs/clxpn0ia\u001b[0m\n",
      "Training Epoch [1/30]: 100%|| 434/434 [07:27<00:00,  1.03s/it, AUC=0.658, acc=0.432, complete_loss=3.8340, sensivity=0.267, specificity=0.822, train_loss=1.3282]\n",
      "Validation Epoch [1/30]: 100%|| 13/13 [00:09<00:00,  1.33it/s, AUC=0.669, acc=0.296, specificity=0.823, val_loss=1.53404567]\n",
      "Training Epoch [2/30]:   0%|                                                                                                                                                    | 0/434 [00:00<?, ?it/s]/usr/local/lib/python3.10/dist-packages/torchmetrics/utilities/prints.py:43: UserWarning: No positive samples in targets, true positive value should be meaningless. Returning zero tensor in true positive score\n",
      "  warnings.warn(*args, **kwargs)  # noqa: B028\n",
      "Training Epoch [2/30]: 100%|| 434/434 [05:52<00:00,  1.23it/s, AUC=0.729, acc=0.48, complete_loss=2.3813, sensivity=0.331, specificity=0.842, train_loss=1.2097]\n",
      "Validation Epoch [2/30]: 100%|| 13/13 [00:07<00:00,  1.84it/s, AUC=0.696, acc=0.142, specificity=0.8, val_loss=2.30798298]\n",
      "Training Epoch [3/30]: 100%|| 434/434 [05:55<00:00,  1.22it/s, AUC=0.751, acc=0.499, complete_loss=1.8454, sensivity=0.352, specificity=0.849, train_loss=1.1691]\n",
      "Validation Epoch [3/30]: 100%|| 13/13 [00:07<00:00,  1.81it/s, AUC=0.56, acc=0.137, specificity=0.801, val_loss=4.21070160]\n",
      "Training Epoch [4/30]: 100%|| 434/434 [05:52<00:00,  1.23it/s, AUC=0.764, acc=0.512, complete_loss=1.5855, sensivity=0.366, specificity=0.854, train_loss=1.1370]\n",
      "Validation Epoch [4/30]: 100%|| 13/13 [00:07<00:00,  1.83it/s, AUC=0.787, acc=0.55, specificity=0.868, val_loss=1.09735714]\n",
      "Training Epoch [5/30]: 100%|| 434/434 [05:52<00:00,  1.23it/s, AUC=0.777, acc=0.527, complete_loss=1.4463, sensivity=0.379, specificity=0.858, train_loss=1.1118]\n",
      "Validation Epoch [5/30]: 100%|| 13/13 [00:07<00:00,  1.79it/s, AUC=0.774, acc=0.479, specificity=0.84, val_loss=1.26006417]\n",
      "Training Epoch [6/30]: 100%|| 434/434 [05:53<00:00,  1.23it/s, AUC=0.787, acc=0.541, complete_loss=1.3603, sensivity=0.392, specificity=0.862, train_loss=1.0881]\n",
      "Validation Epoch [6/30]: 100%|| 13/13 [00:07<00:00,  1.85it/s, AUC=0.76, acc=0.394, specificity=0.83, val_loss=1.37764536]\n",
      "Training Epoch [7/30]: 100%|| 434/434 [05:50<00:00,  1.24it/s, AUC=0.795, acc=0.55, complete_loss=1.3039, sensivity=0.404, specificity=0.865, train_loss=1.0677]\n",
      "Validation Epoch [7/30]: 100%|| 13/13 [00:06<00:00,  1.87it/s, AUC=0.82, acc=0.523, specificity=0.864, val_loss=1.05864617]\n",
      "Training Epoch [8/30]: 100%|| 434/434 [05:48<00:00,  1.25it/s, AUC=0.802, acc=0.557, complete_loss=1.2601, sensivity=0.408, specificity=0.867, train_loss=1.0499]\n",
      "Validation Epoch [8/30]: 100%|| 13/13 [00:06<00:00,  1.86it/s, AUC=0.804, acc=0.537, specificity=0.856, val_loss=1.10919274]\n",
      "Training Epoch [9/30]: 100%|| 434/434 [05:50<00:00,  1.24it/s, AUC=0.81, acc=0.563, complete_loss=1.2228, sensivity=0.419, specificity=0.869, train_loss=1.0309]\n",
      "Validation Epoch [9/30]: 100%|| 13/13 [00:06<00:00,  1.88it/s, AUC=0.8, acc=0.535, specificity=0.854, val_loss=1.12275175]\n",
      "Training Epoch [10/30]: 100%|| 434/434 [05:50<00:00,  1.24it/s, AUC=0.816, acc=0.569, complete_loss=1.1944, sensivity=0.431, specificity=0.871, train_loss=1.0155]\n",
      "Validation Epoch [10/30]: 100%|| 13/13 [00:07<00:00,  1.82it/s, AUC=0.826, acc=0.568, specificity=0.879, val_loss=1.04981519]\n",
      "Training Epoch [11/30]: 100%|| 434/434 [05:54<00:00,  1.22it/s, AUC=0.822, acc=0.575, complete_loss=1.1692, sensivity=0.444, specificity=0.872, train_loss=0.9990]\n",
      "Validation Epoch [11/30]: 100%|| 13/13 [00:07<00:00,  1.85it/s, AUC=0.82, acc=0.54, specificity=0.87, val_loss=1.01104851]\n",
      "Training Epoch [12/30]: 100%|| 434/434 [05:57<00:00,  1.21it/s, AUC=0.826, acc=0.582, complete_loss=1.1495, sensivity=0.462, specificity=0.875, train_loss=0.9864]\n",
      "Validation Epoch [12/30]: 100%|| 13/13 [00:07<00:00,  1.80it/s, AUC=0.833, acc=0.564, specificity=0.865, val_loss=0.98037441]\n",
      "Training Epoch [13/30]: 100%|| 434/434 [05:54<00:00,  1.23it/s, AUC=0.832, acc=0.592, complete_loss=1.1248, sensivity=0.481, specificity=0.878, train_loss=0.9670]\n",
      "Validation Epoch [13/30]: 100%|| 13/13 [00:07<00:00,  1.84it/s, AUC=0.83, acc=0.546, specificity=0.869, val_loss=1.01209917]\n",
      "Training Epoch [14/30]: 100%|| 434/434 [05:54<00:00,  1.22it/s, AUC=0.837, acc=0.594, complete_loss=1.1092, sensivity=0.494, specificity=0.879, train_loss=0.9550]\n",
      "Validation Epoch [14/30]: 100%|| 13/13 [00:07<00:00,  1.84it/s, AUC=0.725, acc=0.258, specificity=0.816, val_loss=2.20036657]\n",
      "Training Epoch [15/30]: 100%|| 434/434 [05:54<00:00,  1.23it/s, AUC=0.844, acc=0.603, complete_loss=1.0860, sensivity=0.499, specificity=0.881, train_loss=0.9346]\n",
      "Validation Epoch [15/30]: 100%|| 13/13 [00:07<00:00,  1.85it/s, AUC=0.842, acc=0.605, specificity=0.883, val_loss=0.98559259]\n",
      "Training Epoch [16/30]: 100%|| 434/434 [05:50<00:00,  1.24it/s, AUC=0.849, acc=0.611, complete_loss=1.0679, sensivity=0.516, specificity=0.884, train_loss=0.9179]\n",
      "Validation Epoch [16/30]: 100%|| 13/13 [00:06<00:00,  1.86it/s, AUC=0.851, acc=0.609, specificity=0.879, val_loss=0.94232274]\n",
      "Training Epoch [17/30]: 100%|| 434/434 [05:49<00:00,  1.24it/s, AUC=0.854, acc=0.618, complete_loss=1.0503, sensivity=0.542, specificity=0.886, train_loss=0.9014]\n",
      "Validation Epoch [17/30]: 100%|| 13/13 [00:07<00:00,  1.85it/s, AUC=0.833, acc=0.573, specificity=0.87, val_loss=0.98836345]\n",
      "Training Epoch [18/30]: 100%|| 434/434 [05:47<00:00,  1.25it/s, AUC=0.86, acc=0.626, complete_loss=1.0338, sensivity=0.548, specificity=0.888, train_loss=0.8847]\n",
      "Validation Epoch [18/30]: 100%|| 13/13 [00:07<00:00,  1.85it/s, AUC=0.836, acc=0.595, specificity=0.882, val_loss=0.94577203]\n",
      "Training Epoch [19/30]: 100%|| 434/434 [05:45<00:00,  1.26it/s, AUC=0.865, acc=0.631, complete_loss=1.0161, sensivity=0.552, specificity=0.89, train_loss=0.8664]\n",
      "Validation Epoch [19/30]: 100%|| 13/13 [00:06<00:00,  1.88it/s, AUC=0.836, acc=0.56, specificity=0.877, val_loss=1.02294623]\n",
      "Training Epoch [20/30]: 100%|| 434/434 [05:44<00:00,  1.26it/s, AUC=0.87, acc=0.641, complete_loss=1.0020, sensivity=0.557, specificity=0.893, train_loss=0.8511]\n",
      "Validation Epoch [20/30]: 100%|| 13/13 [00:06<00:00,  1.89it/s, AUC=0.839, acc=0.605, specificity=0.881, val_loss=0.96789643]\n",
      "Training Epoch [21/30]: 100%|| 434/434 [05:44<00:00,  1.26it/s, AUC=0.876, acc=0.649, complete_loss=0.9764, sensivity=0.58, specificity=0.895, train_loss=0.8239]\n",
      "Validation Epoch [21/30]: 100%|| 13/13 [00:06<00:00,  1.88it/s, AUC=0.846, acc=0.572, specificity=0.88, val_loss=1.02552161]\n",
      "Training Epoch [22/30]: 100%|| 434/434 [05:47<00:00,  1.25it/s, AUC=0.883, acc=0.656, complete_loss=0.9597, sensivity=0.588, specificity=0.898, train_loss=0.8045]\n",
      "Validation Epoch [22/30]: 100%|| 13/13 [00:06<00:00,  1.90it/s, AUC=0.817, acc=0.556, specificity=0.867, val_loss=1.06887255]\n",
      "Training Epoch [23/30]: 100%|| 434/434 [05:50<00:00,  1.24it/s, AUC=0.889, acc=0.667, complete_loss=0.9388, sensivity=0.602, specificity=0.901, train_loss=0.7806]\n",
      "Validation Epoch [23/30]: 100%|| 13/13 [00:06<00:00,  1.89it/s, AUC=0.856, acc=0.597, specificity=0.883, val_loss=0.89971529]\n",
      "Training Epoch [24/30]: 100%|| 434/434 [05:46<00:00,  1.25it/s, AUC=0.896, acc=0.678, complete_loss=0.9145, sensivity=0.62, specificity=0.905, train_loss=0.7524]\n",
      "Validation Epoch [24/30]: 100%|| 13/13 [00:06<00:00,  1.88it/s, AUC=0.839, acc=0.583, specificity=0.868, val_loss=1.11595757]\n",
      "Training Epoch [25/30]: 100%|| 434/434 [05:47<00:00,  1.25it/s, AUC=0.904, acc=0.688, complete_loss=0.8899, sensivity=0.631, specificity=0.909, train_loss=0.7239]\n",
      "Validation Epoch [25/30]: 100%|| 13/13 [00:07<00:00,  1.83it/s, AUC=0.853, acc=0.619, specificity=0.891, val_loss=0.97355685]\n",
      "Training Epoch [26/30]: 100%|| 434/434 [05:48<00:00,  1.25it/s, AUC=0.911, acc=0.703, complete_loss=0.8636, sensivity=0.655, specificity=0.914, train_loss=0.6934]\n",
      "Validation Epoch [26/30]: 100%|| 13/13 [00:07<00:00,  1.82it/s, AUC=0.841, acc=0.573, specificity=0.877, val_loss=1.02595759]\n",
      "Training Epoch [27/30]: 100%|| 434/434 [05:49<00:00,  1.24it/s, AUC=0.918, acc=0.718, complete_loss=0.8391, sensivity=0.677, specificity=0.919, train_loss=0.6640]\n",
      "Validation Epoch [27/30]: 100%|| 13/13 [00:06<00:00,  1.88it/s, AUC=0.843, acc=0.599, specificity=0.879, val_loss=1.12237014]\n",
      "Training Epoch [28/30]: 100%|| 434/434 [05:46<00:00,  1.25it/s, AUC=0.926, acc=0.732, complete_loss=0.8082, sensivity=0.696, specificity=0.923, train_loss=0.6285]\n",
      "Validation Epoch [28/30]: 100%|| 13/13 [00:06<00:00,  1.86it/s, AUC=0.835, acc=0.578, specificity=0.869, val_loss=1.35686101]\n",
      "Training Epoch [29/30]: 100%|| 434/434 [05:46<00:00,  1.25it/s, AUC=0.932, acc=0.748, complete_loss=0.7806, sensivity=0.717, specificity=0.928, train_loss=0.5956]\n",
      "Validation Epoch [29/30]: 100%|| 13/13 [00:06<00:00,  1.87it/s, AUC=0.839, acc=0.578, specificity=0.883, val_loss=1.10539164]\n",
      "Training Epoch [30/30]: 100%|| 434/434 [05:48<00:00,  1.25it/s, AUC=0.941, acc=0.762, complete_loss=0.7459, sensivity=0.734, specificity=0.933, train_loss=0.5555]\n",
      "Validation Epoch [30/30]: 100%|| 13/13 [00:07<00:00,  1.84it/s, AUC=0.852, acc=0.546, specificity=0.877, val_loss=1.48619101]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Test model ResNet50Model - Loss: 1.56, ACC: 0.55, AUC: 0.85, Sensivility: 0.50, Specificity: 0.65\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAABHwAAAJLCAYAAACVJ4EAAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAAC6tUlEQVR4nOzddVhU2f8H8PcwpCAlIKBiYICFikmbGItrBxbqqqtrr93d69r1VbFQ18LuAExMTMxVTBSku+7vD3/MOpIiwx3w/XqeeR7n3DP3fu6HWZY58znnSARBEEBEREREREREREWGitgBEBERERERERFR/uKADxERERERERFREcMBHyIiIiIiIiKiIoYDPkRERERERERERQwHfIiIiIiIiIiIihgO+BARERERERERFTEc8CEiIiIiIiIiKmI44ENEREREREREVMRwwIeIiIiIiIiIqIjhgA8REREREZGCbNmyBRKJBK9evRI7FKXi4uICFxcXscMgKtI44ENERERERIVe+sCKRCLBpUuXMhwXBAFlypSBRCLBL7/8kqdrrFmzBlu2bPnBSImICgYHfIiIiIiIqMjQ1NTEzp07M7T7+vri7du30NDQyPO58zLg06tXL8THx6Ns2bJ5vi4RUV5wwIeIiIiIiIqM1q1bY+/evUhJSZFr37lzJ2xtbWFqalogccTGxgIApFIpNDU1IZFICuS6BSElJQVJSUlih0FEOeCADxERERERFRndu3fH58+fcebMGVlbUlIS9u3bB3d390xfk5aWhmXLlqFatWrQ1NREyZIlMWjQIISHh8v6lCtXDg8fPoSvr69s6lj6GjTp08l8fX0xZMgQmJiYoHTp0nLHvl3D58SJE3B2dkbx4sWhq6uLevXqyVUmPXv2DB07doSpqSk0NTVRunRpdOvWDZGRkdnev4uLC6pXr45bt27Bzs4OWlpaKF++PNatW5eh76dPn9C/f3+ULFkSmpqasLGxwdatW+X6vHr1ChKJBEuWLMGyZctgaWkJDQ0NPHr0KNs4duzYgfr166NYsWIwMDCAk5MTTp8+nWX/pKQkTJs2Dba2ttDT04O2tjYcHR1x4cKFDH13794NW1tbWe5q1KiB5cuXy/WJiIjAyJEjUaZMGWhoaKBixYpYuHAh0tLSso2bqChRFTsAIiIiIiKi/FKuXDk0atQIu3btQqtWrQB8GVyJ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qFV7qELPH39nlULPT0RERESFGyt8iIiIiIiIiIiKmCJZ4UNERCQ6Cb9TISIiIiLxcMCHiIhIESQSsSMgIiIiop8Yv34kIiIiIiIiIipiWOFDRESkCJzSRUREREQi4l+jRERERERERERFDCt8iIiIFIFr+BARERGRiFjhQ0RERERERERUxLDCh4iISBG4hg8RERERiYh/jRIRERERERERFTGs8CEiIlIEruFDRERERCLigA8REZEicEoXEREREYmIf40SERERERERERUxrPAhIiJSBE7pIiIiIiIRscKHiIiIiIiIiKiIYYUPERGRInANHyIiIiISEf8aJSIiIiIiIiIqYljhQ0REpAhcw4eIiIiIRMQKHyIiIiIiIiKiIoYVPkRERIrANXyIiIiISEQc8CEiIlIETukiIiIiIhHx60ciIiIiIiIioiKGFT5ERESKwCldRERERCQi/jVKRERERERERFTEsMKHiIhIEVjhQ0REREQi4l+jRERERERERERFDCt8iIiIFEGFu3QRERERkXhY4UNERFTE+fn5wc3NDebm5pBIJDh48GCGPoGBgWjbti309PSgra2NevXq4fXr17LjCQkJ+OOPP1CiRAno6OigY8eO+PjxYwHeBRERERF9Dw74EBERKYJERbGP7xAbGwsbGxusXr060+MvXryAg4MDrKys4OPjg3v37mHq1KnQ1NSU9Rk1ahSOHDmCvXv3wtfXF+/fv0eHDh1+KEVEREREpDic0kVERKQIEuWZ0tWqVSu0atUqy+OTJ09G69atsWjRIlmbpaWl7N+RkZHYtGkTdu7ciSZNmgAAPD09YW1tjWvXrqFhw4aKC56IiIiI8oQVPkRERIVQYmIioqKi5B6JiYnffZ60tDQcO3YMlStXhqurK0xMTNCgQQO5aV+3bt1CcnIymjVrJmuzsrKChYUFrl69mh+3Q0RERET5jAM+REREiqDgKV3z58+Hnp6e3GP+/PnfHeanT58QExODBQsWoGXLljh9+jTat2+PDh06wNfXFwAQHBwMdXV16Ovry722ZMmSCA4Ozo9sEREREVE+45QuIiKiQmjixIkYPXq0XJuGhsZ3nyctLQ0A8Ouvv2LUqFEAgFq1auHKlStYt24dnJ2dfzxYIiIiIipwHPAhIiJSBAWv4aOhoZGnAZ5vGRkZQVVVFVWrVpVrt7a2xqVLlwAA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IiIiIiIioiKGa/gQEREpgDKt4UNEREREPx8O+BARESkAB3yIiIiISEyc0kVEREREREREVMSwwoeIiEgRWOBDRERERCJihQ8RERERERERURHDCh8iIiIF4Bo+RERERCQmVvgQERERERERERUxrPAhIiJSAFb4EBEREZGYWOFDRERERERERFTEsMKHiIhIAVjhQ0RERERi4oAPERGRInC8h4iIiIhExCldRERERERERERFDCt8iIiIFIBTuoiIiIhITKzwISIiIiIiIiIqYljhQ0REpACs8CEiIiIiMbHCh4iIiIiIiIioiGGFDxERkQKwwoeIiIiIxMQKHyIiIiIiIiKiIoYVPkRERArACh8iIiIiEhMHfIiIiBSB4z1EREREJCJO6SIiIiIiIiIiKmJY4UNERKQAnNJFRERERGJihQ8RERERERERURHDCh8iIiIFYIUPEREREYmJFT5EREREREREREUMK3yIiIgUgAU+RERERCQmVvgQERERERERERUxrPAhIiJSAK7hQ0RERERi4oAPERGRAnC8h4iIiIjExCldRERERERERERFDCt8iIiIFIBTuoiIiIhITKzwISIiIiIiIiIqYljhQ0REpAAs8CEiIiIiMbHCh4iIiIiIiIioiGGFDxERkQKoqLDEh4iIiIjEwwofIiIiIiIiIqIihhU+RERECsA1fIiIiIhITBzwISIiUgBuy05EREREYuKULiIiIiIiIiKiIoYVPgpw+sg+nDmyDyEfPwAASpetgI49f0Pt+vYAgJl/DsSje7flXtOsTQcMGDmpwGNVNvu8NuGq33m8ff0KGhoasKpmg96DRqC0RTlZn/DPodiybhkCbl5DfHwsSpUph849+8POuZl4gSuBIzP6IS7sU4b2ig5tYNtlMOKjwnH34GZ8fHIHyYnxKG5SGlVbdEGZWvYiRFs47N7pha2emxAaGoLKVawwYdJU1KhZU+ywCgXmjlO6iIiIiEhcHPBRgBJGJnDvPxSmpSwgQIDf6aNYPP1PLFzrhTLlLAEATVu3R5c+g2SvUdfQFCtcpfIg4DZat+uKSlbVkJqagu0bV2HG2MFYteUANLW0AADL5k9FbEw0Js9bBl09ffidPYHFM8fjr/VeqFDJSuQ7EE/zP/+GIKTJnkd+CILv6ikoU/vLgI7/9qVIjo+Bw8Cp0NDWQ9AtH1z1XAidMX/D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0xauxLYNKzBn0ggkxMfBrFQZjJg4C3UbOooRslL5+CQAceEhqNCwuVy7ilQVToNm4N6Rrbi4YTZSEuOhY2SGBj1GwfyrSiD6T8tWrREeFoY1q1YgNDQEVayssWb9RpT4yaYl5QVz90Vh+74ifbAnKCgI58+fl1X3AICpqSk+ffok1z8lJQVhYWEwNTUt6FCJiIiIKBckgojzOdq2bYtatWph1qxZmR6/e/cuateujbS0tO86b8Br5ZvSVVhoqklz7kSZ2nnvndghFFqTmrK6jQqepoK/8qgz67xCz397WpM8vU4ikcDb2xvt2rWTtaUP9jx79gwXLlyAsbGx3GsCAwNRtWpV3Lx5U/ZFzOnTp9GyZUu8ffuWizYTERERKSFRK3zGjh2L2NjYLI9XrFgRFy5cKMCIiIiI8ocyTUmOiYnB8+fPZc9fvnyJgIAAGBoawszMDJ06dcLt27dx9OhRpKamytblMTQ0hLq6OqytrdGyZUsMGDAA69atQ3JyMoYOHYpu3bpxsIeIiIhISYla4aMorPDJO1b45B0rfPKOFT4kBkVX+NjOVuwXFremNs51Xx8fHzRunLF/nz59MGPGDJQvXz7T1124cAEuLi4AvuycOXToUBw5cgQqKiro2LEjVqxYAR0dnTzFT0RERESKJWqFDxERUVGlRAU+cHFxyXaDhNx892NoaIidO3fmZ1hEREREpEAqOXchIiIiIiIiIqLChBU+RERECqBMa/gQERER0c+HFT5EREREREREREUMK3yIiIgUgAU+RERERCQmDvgQEREpAKd0EREREZGYOKWLiIiIiIiIiKiIYYUPERGRArDAh4iIiIjExAofIiIiIiIiIqIihhU+RERECsA1fIiIiIhITKzwISIiIiIiIiIqYljhQ0REpAAs8CEiIiIiMbHCh4iIiIiIiIioiGGFDxERkQJwDR8iIiIiEhMHfIiIiBSA4z1EREREJCZO6SIiIiIiIiIiKmJY4UNERKQAnNJFRERERGJihQ8RERERERERURHDCh8iIiIFYIUPEREREYmJFT5EREREREREREUMK3yIiIgUgAU+RERERCQmVvgQERERERERERUxrPAhIiJSAK7hQ0RERERi4oAPERGRAnC8h4iIiIjExCldRERERERERERFDCt8iIiIFIBTuoiIiIhITKzwISIiIiIiIiIqYljhQ0RE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\n",
      "text/plain": [
       "<Figure size 1400x600 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Primera prueba para ver el entrenamiento\n",
    "# He probado antes en local para ver como alcanzaba un 100% de acc y 0.001 de loss con pocos datos\n",
    "train_model(model, trainer, train_dataset, val_dataset, epochs=30, device=device, save_model = \"experimento1.2\", name=\"-Bright\", wdb=True, local=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "270ba781",
   "metadata": {
    "papermill": {
     "duration": 1.350578,
     "end_time": "2025-03-08T00:39:58.713078",
     "exception": false,
     "start_time": "2025-03-08T00:39:57.362500",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "datasetId": 6815705,
     "sourceId": 10955889,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 30919,
   "isGpuEnabled": false,
   "isInternetEnabled": true,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.12"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 10855.46065,
   "end_time": "2025-03-08T00:40:02.791988",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-03-07T21:39:07.331338",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
